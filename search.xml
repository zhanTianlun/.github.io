<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Bug】maven如何排除依赖</title>
    <url>/2019/04/10/1/</url>
    <content><![CDATA[<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>​    java.lang.IncompatibleClassChangeError: Found class org.objectweb.asm.MethodVisitor, but interface was expected at org.lilystudio.smarty4j.Template.toParser(Template.java:357)</p>
<p>java.lang.IncompatibleClassChangeError: Found class org.objectweb.asm.MethodVisitor, but interface was expected at org.lilystudio.smarty4j.Template.toParser(Template.java:357) at org.lilystudio.smarty4j.Template.<init>(Template.java:134) at org.lilystudio.smarty4j.Template.<init>(Template.java:152) at org.lilystudio.smarty4j.Engine.getTemplate(Engine.java:317) at com.doit.framework.mvc.core.Doit.render(Doit.java:769) at com.doit.framework.mvc.core.Doit.forwardTo(Doit.java:711) at com.doit.framework.mvc.core.Doit.doPost(Doit.java:286) at com.doit.framework.mvc.core.Doit.doGet(Doit.java:83) at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at com.doit.framework.mvc.filter.FrameServletFilter.doFilter(FrameServletFilter.java:30) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at com.doit.framework.mvc.filter.SetCharacterEncodingFilter.doFilter(SetCharacterEncodingFilter.java:32) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:493) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:137) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:660) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:798) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:808) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1498) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748)</init></init></p>
<h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>​    这个错误便表示使用jar包文件的依赖冲突引起的，仔细查看jar包，会发现有同一个jar的版本冲突：</p>
<p><img src="https://img-blog.csdnimg.cn/20190726102746100.jpg" alt></p>
<p><img src="https://img-blog.csdnimg.cn/20190726102814362.jpg" alt></p>
<p>​    在引入neo4j的jar包中，也包含了对 asm-6.2.jar 的引用。</p>
<h5 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h5><p>​    在neo4j的jar包中排除asm的依赖。  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.neo4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>neo4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Exclude asm --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ow2.asm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>asm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】享元模式</title>
    <url>/2019/06/04/10/</url>
    <content><![CDATA[<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>​    享元模式又称为轻量级模式，是对象池的一种实现，类似于线程池。线程池可以避免重复的创建和销毁对象，消耗性能。提供了减少对象数量从而改善应用所需的对象结构的方式。其宗旨是共享细粒度对象，将对象的同意访问集中起来，不必为每一个访问者单独创建一个对象，以此来降低系统的消耗，属于结构型的模式。</p>
<p>​    享元模式把对象的状态分为内部状态和外部状态，内部状态是不变的，外部状态是变化的；然后通过不变的部分，达到减少对象数量并减少内存的目的。</p>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>​    当系统中的多处需要一组信息，可以把这些信息封装到一个对象中，然后对对象进行缓存，这样，一个对象就可以提供给对多处访问。避免了多次使用同时创建对象，造成内存的消耗，影响性能。</p>
<p>​    享元模式其实就是工厂模式的一个改进机制，享元模式同样要求创建一个或一组对象，就是通过工厂方法生成对象的，只不过享元模式为工厂创建了一个缓存的功能。主要总结为一下的应用场景。</p>
<ol>
<li>常常应用于系统底层的开发，以便解决系统的性能。</li>
<li>系统有大量的相似对象，需要缓冲池的场景。</li>
</ol>
<p>在生活中的享元模式也很常见，比如各种中介和全国联网的医保。</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>​    生活中肯定会遇到要抢火车篇的情况。那些刷票软件实际上是将我们的信息保存下来，然后定时地去余票里面查询有没有自己需要的余票。假如一张火车票包含出发站，终点站，席次 的信息。然后这里写一个程序利用这些信息去查询有没有余票。</p>
<ol>
<li>创建ITicket接口，提供一个showInfo方法，传入席次信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">(String trunk)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建具体的TIcket类，继承ITicket接口，创建出发站，终点站和价格三个属性，重写showInfo方法，返回票的信息。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">ITicket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="keyword">private</span> String to;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Ticket</span><span class="params">(String from, String to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">(String trunk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = <span class="keyword">new</span> Random().nextInt(<span class="number">500</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s-&gt;%s:%s 价格：%s 元"</span>, <span class="keyword">this</span>.from, <span class="keyword">this</span>.to, trunk, <span class="keyword">this</span>.price));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建一个ticket工厂，提供静态的查询余票的方法，返回ITicket的抽象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ITicket <span class="title">queryTicket</span><span class="params">(String from, String to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Ticket(from, to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>测试代码。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ITicket iTicket = TicketFactory.queryTicket(<span class="string">"杭州东"</span>, <span class="string">"汉口"</span>);</span><br><span class="line">        iTicket.showInfo(<span class="string">"硬座"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>查看结果。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200408115419411.jpg" alt></p>
<p>​    但是这样的写法其实也是每次去查询都创建了一个新的对象，那么其实可以改造一下。</p>
<ol start="6">
<li>改造TicketFactory工厂类，增加缓存机制，创建一个map容器保存对象，不存在才会去创建对象，存在就直接返回该对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, ITicket&gt; sticketPool = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ITicket <span class="title">queryTicket</span><span class="params">(String from, String to)</span> </span>&#123;</span><br><span class="line">        String key = from + <span class="string">"-&gt;"</span> + to;</span><br><span class="line">        <span class="keyword">if</span> (sticketPool.containsKey(key)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"使用缓存: "</span> + key);</span><br><span class="line">            <span class="keyword">return</span> TicketFactory.sticketPool.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"首次查询，创建对象："</span> + key);</span><br><span class="line">        ITicket iTicket = <span class="keyword">new</span> Ticket(from, to);</span><br><span class="line">        TicketFactory.sticketPool.put(key,iTicket);</span><br><span class="line">        <span class="keyword">return</span> iTicket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>重写测试方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ITicket iTicket = TicketFactory.queryTicket(<span class="string">"孝感东"</span>,<span class="string">"汉口"</span>);</span><br><span class="line">        iTicket.showInfo(<span class="string">"上铺"</span>);</span><br><span class="line">        iTicket = TicketFactory.queryTicket(<span class="string">"孝感东"</span>,<span class="string">"汉口"</span>);</span><br><span class="line">        iTicket.showInfo(<span class="string">"上铺"</span>);</span><br><span class="line">        iTicket = TicketFactory.queryTicket(<span class="string">"杭州东"</span>,<span class="string">"汉口"</span>);</span><br><span class="line">        iTicket.showInfo(<span class="string">"中铺"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>查看新的测试结果。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200408143418462.jpg" alt></p>
<h5 id="享元模式在源码中的应用"><a href="#享元模式在源码中的应用" class="headerlink" title="享元模式在源码中的应用"></a>享元模式在源码中的应用</h5><p>​    来看看在Integer中，Integer是怎么将数据存在缓存中，然后从缓存中去取的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = Integer.valueOf(<span class="number">100</span>);</span><br><span class="line">        Integer b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        Integer c = Integer.valueOf(<span class="number">1000</span>);</span><br><span class="line">        Integer d = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"a==b:"</span> + (a == b));</span><br><span class="line">        System.out.println(<span class="string">"c==d:"</span> + (c == d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    运行上面的代码，可以看到，a和b是相等的，c和d是不相等的。</p>
<p><img src="https://img-blog.csdnimg.cn/20200408160700359.jpg" alt></p>
<p>​    这是为什么呢，这里点开Integer的valueOf方法去看看。</p>
<p><img src="https://img-blog.csdnimg.cn/20200408160841432.jpg" alt></p>
<p>​    可以看到，如果传入的i值大于等于IntegerCache.low或者小于等于IntegerCache.high，那么就会从cha么就会从cache缓存里面取，如果不是的话就新建一个Integer对象。而IntegerCache.low的值是-128，IntegerCache.high的值是127。</p>
<p><img src="https://img-blog.csdnimg.cn/20200408161245410.png" alt></p>
<p><img src="https://img-blog.csdnimg.cn/20200408161258604.jpg" alt></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>享元模式的优点：</p>
<p>​    1.减少对象的创建，降低内存中对象的数量，降低系统中的内存，提高效率。</p>
<p>​    2.减少内存之外的其他资源的占用。</p>
<p>享元模式的缺点：</p>
<p>​    1.关注内部，外部状态，关注线程安全问题。</p>
<p>​    2.使系统，程序的逻辑复杂化。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【Bug】Idea Debug断点端口被占用</title>
    <url>/2019/07/02/12/</url>
    <content><![CDATA[<p>​    有时候，用idea来debug断点调试的时候，会提示debug断点的端口被占用。解决办法：</p>
<ol>
<li>点击任务栏上的Edit Configurations…</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200417093949723.jpg" alt></p>
<ol start="2">
<li>找到debug的端口号。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200417094124282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW50aWFubHVu,size_16,color_FFFFFF,t_70" alt></p>
<ol start="3">
<li><p>在命令行提示Port找到UID</p>
</li>
<li><p>根据UID找到进程</p>
</li>
<li><p>杀死进程</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200417094852485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW50aWFubHVu,size_16,color_FFFFFF,t_70" alt></p>
<ol start="6">
<li>成功启动项目。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】工厂模式之简单工厂模式</title>
    <url>/2019/04/13/3/</url>
    <content><![CDATA[<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>​    简单工厂模式是指由一个工厂决定创建哪一种产品类的实例。简单工厂模式适用于需要创建较少的产品实例。客户端在创建的时候，只需要传入创建的参数，不需要知道是如何创建的。</p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p>​    2.1 场景：</p>
<p>​    有一个支付场景，支付的方式有多种，微信支付，阿里支付，银联支付。如何实现简单工厂模式。</p>
<p>​    2.2 步骤：</p>
<p>​    （1）.创建一个抽象的支付接口，只提供一个抽象的方法pay。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPay</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    (2) .创建一个工厂，用来生产各种支付方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPay <span class="title">create</span><span class="params">(Class&lt;? extends IPay&gt; clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(clazz != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    （3）.创建各种支付类，AliPay，WechatPay 等等，继承IPay接口，实现pay方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliPay</span> <span class="keyword">implements</span> <span class="title">IPay</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用支付宝付款"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatPay</span> <span class="keyword">implements</span> <span class="title">IPay</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用微信付款"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    （4）.在客服端new出一个工厂实例，根据需要传入具体要生产的是那种支付方式即可，这里传入的参数是类的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PayFactory payFactory = <span class="keyword">new</span> PayFactory();</span><br><span class="line"><span class="comment">//        IPay iPay = payFactory.create(AliPay.class);</span></span><br><span class="line">        IPay iPay = payFactory.create(WeChatPay<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        iPay.pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>​    如果以后出现了新的支付方式，我们不需要再去修改工厂里面的方法，只需要创建支付的实例类即可。这样就符合了软件设计的开闭原则，但是简单工厂模式也有它的缺点，以后如果支付的方式非常多，这个工厂的职责就会过重。所以简单工厂模式更适用于创建较少产品的场景，不适用于过于复杂的场景模式。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】工厂模式之工厂方法模式</title>
    <url>/2019/04/22/4/</url>
    <content><![CDATA[<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>​    工厂方法模式是指定义一个创建对象的接口，然后实现这个接口的工厂来决定创建什么样的实例。工厂方法让类的实例推迟到子类中进行。在这个模式中，只关心需要创建的是什么工厂，不需要关心创建的细节。而且新加入的产品符合开闭原则。</p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p>1.场景</p>
<p>​    有一个支付场景，支付的方式有多种，微信支付，阿里支付，银联支付。如何实现工厂方法模式。</p>
<p>2.步骤</p>
<p>（1） 创建支付接口，里面定义抽象的支付方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPay</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2） 创建工厂接口，提供创建的方法，返回支付接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPayFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">IPay <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3） 创建具体的支付类，AliPay,WechatPay,实现IPay接口，重写支付方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliPay</span> <span class="keyword">implements</span> <span class="title">IPay</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用支付宝支付"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.gupao.vip.pay.factorymethod;</span><br><span class="line"></span><br><span class="line">public class WechatPay implements IPay &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void pay() &#123;</span><br><span class="line">        System.out.println(&quot;用微信支付&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4） 创建微信支付和阿里支付的工厂类，继承抽象工厂，重写抽象工厂的create方法，返回具体的支付类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliPayFactory</span> <span class="keyword">implements</span> <span class="title">IPayFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPay <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AliPay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatPayFactory</span> <span class="keyword">implements</span> <span class="title">IPayFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPay <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WechatPay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5） 在客服端创建所需要的阿里支付和微信支付的工厂，然后由工厂来创建具体的支付类，然后就可以调用各自的支付方法了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IPayFactory aliPayFactory = <span class="keyword">new</span> AliPayFactory();</span><br><span class="line">        IPay aliPay = aliPayFactory.create();</span><br><span class="line">        aliPay.pay();</span><br><span class="line"></span><br><span class="line">        IPayFactory wechatPayFactory = <span class="keyword">new</span> WechatPayFactory();</span><br><span class="line">        IPay wwechatPay = wechatPayFactory.create();</span><br><span class="line">        wwechatPay.pay();</span><br><span class="line"></span><br><span class="line">        IPayFactory uniPayFactory = <span class="keyword">new</span> UniPayFactory();</span><br><span class="line">        IPay uniPay = uniPayFactory.create();</span><br><span class="line">        uniPay.pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>​    工厂方法模式只要解决了产品的扩展问题。在简单工厂中，如果在支付的同时需要加入其他的逻辑，而每个支付的逻辑都不一样，那么这个工厂的职责会变得非常的重。有点像万能工厂，不易于维护。而根据软件设计的单一职责原则，我们可以将工厂的职责拆分开来，专人干专事。阿里支付工厂就用来创建阿里支付，微信支付工厂就用来创建微信支付。</p>
<p>​    但同时这种设计模式也有它的缺点。它增加了类的创建个数，提升了系统的复杂度和可理解度。</p>
<p>​    所以，工厂方法模式适用的场景是：1.创建对象需要大量重复的代码。2.客服端（应用层）不依赖于产品的实例如何被创建。3.一个类是通过其子类来指定创建对象的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【软件设计原则】七大软件设计原则</title>
    <url>/2019/04/12/2/</url>
    <content><![CDATA[<h5 id="开闭原则：对扩展开放，对修改关闭。"><a href="#开闭原则：对扩展开放，对修改关闭。" class="headerlink" title="开闭原则：对扩展开放，对修改关闭。"></a>开闭原则：对扩展开放，对修改关闭。</h5><p>​    例子：咕泡课程：有java,前端，测试等等。每种课程有id,名称，价格。但是都不一样：新建一个抽象的接口Icouce，里面有三个方法，getid,getName,getPrice，新建一个javaCource，继承接口,重写三个方法。然后创建一个构造器。然后创建一个测试类，创建抽象接口的具体实现类，给属性赋值。然后就可以得到javaCouce的id,name,privce。 问题是现在课程可能会打折。所以就要创建一个javaDiscountCouse类在里面对price进行打折。这样就可以在获取折后价格的同时获取到原价了。</p>
<h5 id="依赖倒置原则："><a href="#依赖倒置原则：" class="headerlink" title="依赖倒置原则："></a>依赖倒置原则：</h5><p>​    高层模块不应该依赖底层模块。两者都应该依赖其抽象。抽象应该依赖细节，细节应该依赖抽象。针对接口编程，不针对实现编程。 可以减少类之间的耦合性，提高系统的稳定性。提高代码的可阅读性和可维护性，可以降低修改程序造成的风险。</p>
<h5 id="单一职责原则："><a href="#单一职责原则：" class="headerlink" title="单一职责原则："></a>单一职责原则：</h5><p>​    不要存在一个导致类变更的原因。一个类，接口，方法只负责一项职责。优点：降低类的耦合性，提高类的可阅读性，提高系统的可维护性，降低变更引起的风险。</p>
<h5 id="接口隔离原则："><a href="#接口隔离原则：" class="headerlink" title="接口隔离原则："></a>接口隔离原则：</h5><p>​    用多个单一的接口，而不是一个统一的接口。客户端不应该依赖不需要的接口。注意：一个类对应一个类的依赖应该建立在最小的接口上，建立单一的接口，不要建立庞大臃肿的解耦。尽量的细化接口，接口中的方法尽量的少。注意适度原则，一定要尽量的适度。</p>
<h5 id="迪米特法则："><a href="#迪米特法则：" class="headerlink" title="迪米特法则："></a>迪米特法则：</h5><p>​    一个对象应该对其他对象保持最少的了解，又叫最少知道原则。尽量降低类和类之间的耦合。强调只和朋友交流，不和陌生人说话。朋友，出现在成员变量，方法的输入输出参数中的类为成员朋友类，出现在方法体内部的类不是朋友类。</p>
<h5 id="里式替换原则："><a href="#里式替换原则：" class="headerlink" title="里式替换原则："></a>里式替换原则：</h5><p>​    如果每一个类型为T1的对象O1,都有类型为T2的对象O2,使得以T1定义的所有程序P在所有的对象O1都替换成O2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。定义扩展：一个软件实体如果适用一个父类的话，那一定适用于其子类，所有引用父类的地方必须能透明的使用其子类对象，子类对象能够替换父类对象，而程序逻辑不变。</p>
<p>​        引申意义：子类可以扩展父类的功能，但是不能改变父类的功能。</p>
<p>​        含义1：子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</p>
<p>​        含义2：子类中可以增加自己特有的方法。</p>
<p>​        含义3：当子类的方法重载父类的方法时，方法的前置条件（即方法的输入，入参）要比父类的输入参数要宽松。</p>
<p>​        含义4：当子类的方法实现父类的方法时（重写，重载或实现抽象的方法），方法的后置条件（即方法的输出，返回值）要比父类更严格或相等。</p>
<h5 id="合成，聚合复用原则："><a href="#合成，聚合复用原则：" class="headerlink" title="合成，聚合复用原则："></a>合成，聚合复用原则：</h5><p>​    尽量使用对象组合，聚合。而不是继承达到软件复用的目的。聚合has-a和组合contains-a 优点：可以是系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】工厂模式之抽象工厂模式</title>
    <url>/2019/04/24/5/</url>
    <content><![CDATA[<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>​    抽象工厂模式是指提供一系列相互依赖或者相关的接口，无需指定他们具体的类。客户端（应用层）不依赖于产品实例如何被创建的细节。强调的是一系列相关的产品对象一起使用创建对象需要大量重复的代码，需要提供一个产品类的库。所以的产品以同样的接口出现，从而使客户端不依赖于具体的实现。</p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><h5 id="1-1-场景"><a href="#1-1-场景" class="headerlink" title="1.1 场景"></a>1.1 场景</h5><p>​    有一个支付场景，要支付宝支付和微信支付，支付宝支付和微信支付都可以聊天，都可以借钱（假设）。</p>
<h5 id="1-2-步骤"><a href="#1-2-步骤" class="headerlink" title="1.2 步骤"></a>1.2 步骤</h5><p>（1） 创建抽象的聊天和借钱的接口，提供抽象的聊天和借钱的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITalk</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILend</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lend</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2） 创建支付的抽象 工厂类，提供公开的初始化方法，提供抽象的创造聊天和支付的方法，返回值是抽象的聊天和借钱。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PayFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"初始化数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ITalk <span class="title">createTalk</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ILend <span class="title">createLend</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliPayTalk</span> <span class="keyword">implements</span> <span class="title">ITalk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"支付宝聊天"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatTalk</span> <span class="keyword">implements</span> <span class="title">ITalk</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"微信可以聊天"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatLend</span> <span class="keyword">implements</span> <span class="title">ILend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"微信可以借钱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4） 创建阿里支付工厂和微信支付工厂，继承支付工厂接口，实现其抽象的方法。在方法中创建具体的聊天和借钱的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliPayFactory</span> <span class="keyword">extends</span> <span class="title">PayFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ITalk <span class="title">createTalk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AliPayTalk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ILend <span class="title">createLend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AliPayLend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatPayFactory</span> <span class="keyword">extends</span> <span class="title">PayFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ITalk <span class="title">createTalk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WechatTalk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ILend <span class="title">createLend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WechatLend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5） 在客户端创建支付宝支付和微信支付的工厂，调用工厂的创建聊天和借钱的接口创建具体的聊天和借钱的实例，最后调用聊天和借钱的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AliPayFactory aliPayFactory = <span class="keyword">new</span> AliPayFactory();</span><br><span class="line">        aliPayFactory.createTalk().talk();</span><br><span class="line">        aliPayFactory.createLend().lend();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---------"</span>);</span><br><span class="line"></span><br><span class="line">        WechatPayFactory wechatPayFactory = <span class="keyword">new</span> WechatPayFactory();</span><br><span class="line">        wechatPayFactory.createTalk().talk();</span><br><span class="line">        wechatPayFactory.createLend().lend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>​    不知道大家有没有发现，如果在上面的代码中，需要给阿里支付和微信支付添加额外的功能，则需要改变抽象工厂和具体工厂的代码。这样就违背的软件设计的开闭原则。所以抽象工厂模式也是有缺点的。第一，产品族需要扩展功能很麻烦，需要修改抽象接口的代码。第二，创建的抽象类多，增加了系统的抽象性和理解难度。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】装饰器模式</title>
    <url>/2019/06/03/9/</url>
    <content><![CDATA[<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>​    装饰器模式也称为包装模式，是指在不改变原有对象的基础上，将功能附加到原有对象上，提供了比继承更有弹性的替代方案（扩展原有对象的功能），属于结构型模式。</p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p>​    这里举例一个日常生活常见的例子。我们每天吃早饭可能会买的煎饼果子。煎饼果子是可以加上调料和其他肉食的。如果觉得不够吃，可以加上鸡蛋或者香肠。</p>
<ol>
<li>创建煎饼果子类。提供getName和getPrice方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatterCake</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"煎饼"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>觉得不够吃，想加一个鸡蛋。创建一个类BattarCakeWithOneEgg继承BatterCake类，重写getName和getPrice方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BattarCakeWithOneEgg</span> <span class="keyword">extends</span> <span class="title">BatterCake</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="string">"加一个鸡蛋"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>还是觉得不够吃，想再加一个香肠。创建一个类继续继承BattarCakeWithOneEgg，重写getName和getPrice方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatterCakeWithOneEggOneSausage</span> <span class="keyword">extends</span> <span class="title">BattarCakeWithOneEgg</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="string">"加一个香肠"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>测试代码。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//想吃煎饼果子</span></span><br><span class="line">        BatterCake batterCake = <span class="keyword">new</span> BatterCake();</span><br><span class="line">        System.out.println(batterCake.getName() + <span class="string">",价格:"</span> + batterCake.getPrice());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//想再加一个鸡蛋</span></span><br><span class="line">        BattarCakeWithOneEgg battarCakeWithOneEgg = <span class="keyword">new</span> BattarCakeWithOneEgg();</span><br><span class="line">        System.out.println(battarCakeWithOneEgg.getName() + <span class="string">",价格："</span> + battarCakeWithOneEgg.getPrice());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//想再加一个鸡蛋一个香肠</span></span><br><span class="line">        BatterCakeWithOneEggOneSausage batterCakeWithOneEggOneSausage = <span class="keyword">new</span> BatterCakeWithOneEggOneSausage();</span><br><span class="line">        System.out.println(batterCakeWithOneEggOneSausage.getName() + <span class="string">",价格："</span> + batterCakeWithOneEggOneSausage.getPrice());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>看看结果。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200403151618230.jpg" alt></p>
<pre><code>这个时候，如果我想再一个鸡蛋。就需要继续继承BatterCakeWithOneEggOneSausage 这个类。想再加，就必须再继承。</code></pre><p>​    这样不停的定制，显然是不科学的做法。</p>
<p>   下面就用装饰器模式来改造下这个代码。</p>
<ol>
<li>创建一个抽象的煎饼对象，提供getName和getPrice方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BatterCake</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建一个基础的煎饼果子类（基础套餐）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBatterCake</span> <span class="keyword">extends</span> <span class="title">BatterCake</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"煎饼"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建一个煎饼果子基础套餐的装饰器，将抽象的BatterCake类以静态代理的方式注入到BatterCakeDecorator 的构造方法中，然后调用它的getName和getPrice的方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatterCakeDecorator</span> <span class="keyword">extends</span> <span class="title">BatterCake</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BatterCake batterCake;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BatterCakeDecorator</span><span class="params">(BatterCake batterCake)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.batterCake = batterCake;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> batterCake.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> batterCake.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建一个加了鸡蛋的煎饼果子套餐，继承BatterCake，在构造方法中注入BatterCake，然后重写getName和getPrice的方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatterCakeEggDecorator</span> <span class="keyword">extends</span> <span class="title">BatterCakeDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BatterCakeEggDecorator</span><span class="params">(BatterCake batterCake)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(batterCake);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="string">"加一个鸡蛋"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>创建一个加香肠的煎饼果子套餐，同样继承BatterCake，在构造方法中注入BatterCake，然后重写getName和getPrice的方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatterCakeSausageDecorator</span> <span class="keyword">extends</span> <span class="title">BatterCakeDecorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BatterCakeSausageDecorator</span><span class="params">(BatterCake batterCake)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(batterCake);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="string">"加一个香肠"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>测试。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BatterCake batterCake;</span><br><span class="line">        <span class="comment">//点一个基础套餐</span></span><br><span class="line">        batterCake = <span class="keyword">new</span> BaseBatterCake();</span><br><span class="line">        <span class="comment">//加一个鸡蛋</span></span><br><span class="line">        batterCake = <span class="keyword">new</span> BatterCakeEggDecorator(batterCake);</span><br><span class="line">        <span class="comment">//加一个香肠</span></span><br><span class="line">        batterCake = <span class="keyword">new</span> BatterCakeSausageDecorator(batterCake);</span><br><span class="line">        <span class="comment">//再加一个香肠</span></span><br><span class="line">        batterCake = <span class="keyword">new</span> BatterCakeSausageDecorator(batterCake);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"买了"</span> + batterCake.getName() + <span class="string">",一共花了"</span> + batterCake.getPrice() + <span class="string">"元钱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>查看结果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200403153005239.jpg" alt></p>
</li>
<li><p>看一下类图。</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200403153915766.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW50aWFubHVu,size_16,color_FFFFFF,t_70" alt></p>
<p>​    这里的BatterCake就是一个抽象的组件，它充当了被装饰的原始对象，规定了被装饰对象的行为。BaseBatterCake就是具体组件，他是实现或者继承抽象组件的一个具体对象，也就是被装饰对象。BatterCakeDecorator就是通用的装饰器，它的内部必然有一个属性指向抽象的组件。它的实现一般是一个抽象类，主要是为了让它的子类按照其构造形式传入一个抽象的组件，这是强制的通用行为。而如果系统中的装饰逻辑比较的单一，并不需要许多的装饰器，那么就可以直接省略这个类，直接实现一个具体的装饰器就可以。而下面的 BatterCakeEggDecorator 和 BatterCakeSausageDecorator 就是具体的装饰器对象。理论上，每一个对象都扩展了BaseBatterCake的功能。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p> 装饰器模式角色分配符合设计模式的里氏替换原则，依赖倒置原则，从而使得它具备很强的扩展性，最终满足开闭原则。</p>
<ol>
<li>装饰器模式和代理模式的对比</li>
</ol>
<p>​     装饰器更强调对被装饰对象自身的扩展，而代理模式更强调代理对象的功能增强。</p>
<ol start="2">
<li>代理模式的优点</li>
</ol>
<p>​    （1）.是继承的有力补充，比继承灵活，不改变原有对象的情况下动态地给一个对象扩展功能，即插即用。</p>
<p>​    （2）.可以通过构造不同的装饰类，对这些类进行排列组合，实现不同的效果。</p>
<p>​    （3）.装饰器模式完全遵循开闭原则。</p>
<ol start="3">
<li>代理模式的缺点</li>
</ol>
<p>​    （1）.会出现很多的代码，出现更多的类，增加了系统的复杂度。</p>
<p>​    （2）.动态装饰时，多层装饰会比较复杂。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】代理模式</title>
    <url>/2019/05/05/7/</url>
    <content><![CDATA[<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>​    代理模式是指为对象提供一种代理，以控制对该对象的访问，属于一种结构型模式。在某些情况下，一个对象不能直接访问另一个对象，代理模式就在客户端和被服务端之间起到了一个中介的作用。</p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><h5 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1.静态代理"></a>1.静态代理</h5><p>​    场景：张三要结婚，但是由于工作繁忙，找不到对象。那么张三的父亲可以代理张三找对象。</p>
<p>(1) 创建IPerson接口，给出找对象的抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findLove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 创建张三的实例，继承IPerson接口，重写找对象的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhanSan</span> <span class="keyword">implements</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findLove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"张三要求：肤白貌美大长腿"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3) 创建张三的代理对象（他父亲），在构造方法中传入张三，重写张三的找对象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangLaoSan</span> <span class="keyword">implements</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZhanSan zhanSan;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZhangLaoSan</span> <span class="params">(ZhanSan zhanSan)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zhanSan = zhanSan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findLove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"张老三开始物色"</span>);</span><br><span class="line">        zhanSan.findLove();</span><br><span class="line">        System.out.println(<span class="string">"开始交往"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4) 测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ZhangLaoSan zhangLaoSan = <span class="keyword">new</span> ZhangLaoSan(<span class="keyword">new</span> ZhanSan());</span><br><span class="line">        zhangLaoSan.findLove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(5).结果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200330175323258.jpg" alt></p>
<p>​    这个场景有个弊端，如果还有赵六要相亲，就需要再创建一个赵六的代理。如果还有其他对象也需要相亲的话，就需要创建更多的代理对象，这样做就违背了开闭原则。而在真实的场景中，有专门找对象的中介或者机构：媒婆。所以这里可以用动态代理来构建媒婆这样角色。</p>
<h5 id="2-jdk动态代理"><a href="#2-jdk动态代理" class="headerlink" title="2.jdk动态代理"></a>2.jdk动态代理</h5><p>​    Java的生态中，用的比较多的是JDK自带的动态代理。</p>
<p>（1）创建媒婆代理类，继承InvocationHandler接口，重写invoke方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeiPoProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IPerson target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPerson <span class="title">getInstance</span><span class="params">(IPerson target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        Class&lt;?&gt; clazz = target.getClass();</span><br><span class="line">        <span class="keyword">return</span> (IPerson) Proxy.newProxyInstance(clazz.getClassLoader(),clazz.getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = method.invoke(<span class="keyword">this</span>.target,args);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始交往"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始物色"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 创建赵六实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhaoLiu</span> <span class="keyword">implements</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findLove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"赵六要求：有车有房学历高"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3) 测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MeiPoProxy proxy = <span class="keyword">new</span> MeiPoProxy();</span><br><span class="line">        IPerson zhangsan =  proxy.getInstance(<span class="keyword">new</span> ZhanSan());</span><br><span class="line">        zhangsan.findLove();</span><br><span class="line"></span><br><span class="line">        IPerson zhaoliu = proxy.getInstance(<span class="keyword">new</span> ZhaoLiu());</span><br><span class="line">        zhaoliu.findLove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4) 结果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200331093240916.jpg" alt></p>
<h5 id="3-cglib动态代理"><a href="#3-cglib动态代理" class="headerlink" title="3.cglib动态代理"></a>3.cglib动态代理</h5><p>(1) 引入cglib的jar包。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> (2) 写一个孟婆类继承MethodInterceptor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibMeipo</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Class&lt;?&gt; clazz)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//要把哪个设置为即将生产的新的父类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//业务的增强</span></span><br><span class="line">        before();</span><br><span class="line">        Object obj = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是媒婆：我要给你找对象，现在已确认需求"</span>);</span><br><span class="line">        System.out.println(<span class="string">"开始物色"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"已经找到"</span>);</span><br><span class="line">        System.out.println(<span class="string">"开始交往"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3) 创建单身客户类。这里可以看到Customer是没有实现任何接口的。它是通过动态继承代理对象类来实现动态代理的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findLove</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"客户要求： 肤白貌美大长腿"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4) 写一个测试类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Customer customer = (Customer) <span class="keyword">new</span> CglibMeipo().getInstance(Customer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            customer.findLove();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(5) 查看测试结果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200331094928472.jpg" alt></p>
<p>​    那么cglib的底层是如何实现动态代理的呢，这里可以通过一行代码，将cglib动态生成的代理class从内存读取到磁盘中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.core.DebuggingClassWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//利用cglib的代理类将内存中的.class写入磁盘</span></span><br><span class="line">            System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY,<span class="string">"E://cglib_proxy_class/"</span>);</span><br><span class="line"></span><br><span class="line">            Customer customer = (Customer) <span class="keyword">new</span> CglibMeipo().getInstance(Customer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            customer.findLove();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这时可以在E盘根目录中看到从内存中读取的文件。打开目录就能看到cglib动态的生成了三个class文件。</p>
<p><img src="https://img-blog.csdnimg.cn/2020033109574010.jpg" alt></p>
<p>​    把第二个文件Customer$$EnhancerByCGLIB$$ef2de5ed.class拖入到idea编辑器中，可以看到，这是cglib动态生成的一个代理对象，这个对象继承了目标对象。</p>
<p><img src="https://img-blog.csdnimg.cn/20200331100243244.jpg" alt></p>
<p>​    重写了目标对象的方法。</p>
<p><img src="https://img-blog.csdnimg.cn/20200331100412312.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW50aWFubHVu,size_16,color_FFFFFF,t_70" alt></p>
<p>​    可以看到这里有一个CGLIB$findLove$0() 的方法，这个方法是被 CglibMeipo类的 method.invokeSuper() 调用的，而下面的 findLove() 方法是被MethodProxy的invoke()方法调用的。</p>
<p>​    所以总的来说，调用的顺序是，代理对象调用findlove() –&gt; 调用拦截器 –&gt; methodProxy. invokeSuper() –&gt; CGLIB$findLove$0() –&gt; Customer.findLove()。</p>
<p>​    我们可以点开methodProxy. invokeSuper()的源码看看。</p>
<p><img src="https://img-blog.csdnimg.cn/20200331102535128.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW50aWFubHVu,size_16,color_FFFFFF,t_70" alt></p>
<p>​    可以发现，这里获取了代理对象的FastClass信息。然后调用了被代理对象的对应方法。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>1.静态代理和动态代理</p>
<p>（1）静态代理，实际上就是一种通过继承来重写方法并实现方法增强的，代理类是没有实现任何接口的。而动态代理是通过实现jdk或者cglib的接口来创建一个拦截器，然后在拦截器中进行方法增强的。</p>
<p>（2）静态代理只能手动完成代理操作，如果代理类增加了方法，代理类需要同步增加该方法。违背了开闭原则。</p>
<p>2.jdk动态代理和cglib动态代理</p>
<p>（1）jdk动态代理要求被代理对象必须要实现一个接口，而cglib动态代理则只需要代理对象是一个类即可。</p>
<p> (2) jdk动态代理调用代理方法是通过反射机制调用的，而cglib动态代理是通过FastClass机制直接调用的，所以cglib动态代理的执行效率要更高。</p>
<p>3.代理模式的优点</p>
<p>（1）代理模式将目标对象与代理对象分离，起到了保护目标对象的作用。</p>
<p>（2）在一定程度上降低了系统的耦合性，扩展性比较好。</p>
<p>（3）可以增强目标对象的功能。</p>
<p>4.代理模式的缺点</p>
<p>（1）代理模式会造成系统设计中类的增加。</p>
<p>（2）在客户端和服务端多出了一个代理对象，请求的处理速度会变慢。</p>
<p>（3）增加了系统的复杂度。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】门面模式</title>
    <url>/2019/05/22/8/</url>
    <content><![CDATA[<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>​    门面模式又叫外观模式，它提供了一个同意的接口，用来对访问子系统中的多个接口。它的主要特性是定义了一个高层的接口，让子系统更容易调用，是属于一种结构型的设计模式。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p> 1.通用的写法，这里创建三个子系统和和一个门面系统，门面系统提供三个方法分别调用子系统的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystemA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystemB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do b"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystemC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SubSystemA subSystemA = <span class="keyword">new</span> SubSystemA();</span><br><span class="line">    <span class="keyword">private</span> SubSystemB subSystemB = <span class="keyword">new</span> SubSystemB();</span><br><span class="line">    <span class="keyword">private</span> SubSystemC subSystemC = <span class="keyword">new</span> SubSystemC();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subSystemA.doA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subSystemB.doB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subSystemC.doC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.写一个测试类，创建门面系统，然后调用方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">        facade.doA();</span><br><span class="line">        facade.doB();</span><br><span class="line">        facade.doC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.查看结果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200403105801413.jpg" alt></p>
<p>4.类的结构图。</p>
<p><img src="https://img-blog.csdnimg.cn/20200403110106161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW50aWFubHVu,size_16,color_FFFFFF,t_70" alt></p>
<h5 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h5><p>​    比如模拟一个商品积分兑换的场景，兑换一个商品需要三个步骤：1.确认用户的积分是否足够。2.完成支付流程。3.进入物流。这里就分别创建这三个系统（Service类），然后创建一个门面系统。然后在门面系统中分贝调用这三个子系统的服务。</p>
<p>1.创建商品类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 2.创建积分校验系统。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 积分校验系统</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QulifyService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvilible</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"积分库积分校验通过，足够兑换物品"</span> + order.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 3.创建支付系统。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支付系统</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pay</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"兑换商品"</span> + order.getName() + <span class="string">"成功，积分已被扣除"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.创建物流系统。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 物流系统</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeliveryService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delivery</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入物流系统，商品已在快递中..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"666"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.创建门面系统。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFacadeService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> QulifyService qulifyService = <span class="keyword">new</span> QulifyService();</span><br><span class="line">    <span class="keyword">private</span> PayService payService = <span class="keyword">new</span> PayService();</span><br><span class="line">    <span class="keyword">private</span> DeliveryService deliveryService = <span class="keyword">new</span> DeliveryService();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (qulifyService.isAvilible(order)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (payService.pay(order)) &#123;</span><br><span class="line">                String deliveryNo = deliveryService.delivery(order);</span><br><span class="line">                System.out.println(<span class="string">"下单成功，物流单号为："</span> + deliveryNo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 6.测试调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setName(<span class="string">"《Java 技术核心卷2》"</span>);</span><br><span class="line"></span><br><span class="line">        OrderFacadeService orderFacadeService = <span class="keyword">new</span> OrderFacadeService();</span><br><span class="line">        orderFacadeService.exchange(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.查看结果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200403111025138.jpg" alt></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>1.门面模式的优点：</p>
<p>   （1）简化了调用的过程，无需深入的了解子系统，以防给子系统带来风险。</p>
<p>   （2）减少系统依赖，降低耦合。</p>
<p>   （3）更好的划分了访问的层次，提高了安全性。</p>
<p>   （4）遵循迪米特法则，即最少知道原则。</p>
<p>2.门面模式的缺点：</p>
<p>   （1）当子系统的功能需要扩展时，门面系统也需要进行扩展。容易带来未知的风险。</p>
<p>   （2）不符合开闭原则。</p>
<p>   （3）某些情况下可能违背单一职责原则。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【Spring】用300行代码实现spring1.0版本（详细注释）</title>
    <url>/2019/07/01/11/</url>
    <content><![CDATA[<p>​    通过手写来实现SpringMvc三层模型,spring的Ioc控制反转，Di依赖注入的功能，主要分为配置阶段，初始化阶段和运行阶段这三个阶段。</p>
<h5 id="配置阶段"><a href="#配置阶段" class="headerlink" title="配置阶段"></a>配置阶段</h5><ol>
<li>配置web.xml，设定init-param和param-name ， 设置url-parttern，方法的过滤路径为 /*。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span> <span class="attr">xmlns:javaee</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:web</span>=<span class="string">"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"2.4"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>gpmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.alan.mvcframework.v2.servlet.MyDispatchServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>application.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>gpmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建 application.properties ,配置包扫描的路径。</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">scanPackage</span>=<span class="string">com.alan.demo</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建自己的注解文件。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GPAutowired &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GPController &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GPRequestMapping &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GPRequestParam &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GPService &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>引入 servlet-api 的依赖jar包。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;servlet.api.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h5><p>​    创建一个类继承 HttpServlet,重写 doGet ,doPost ,init 方法 。</p>
<ol>
<li>获取包扫描的配置信息。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doLoadConfig</span><span class="params">(String contextConfigLocation)</span> </span>&#123;</span><br><span class="line">    InputStream is = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(contextConfigLocation);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//存入一个property里面</span></span><br><span class="line">        contextConfig.load(is);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>扫描包下的所有类，将类名全路径名称存入数组中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doScanner</span><span class="params">(String scanPackage)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取classLoader下面该路径的url,由/拼接</span></span><br><span class="line">    URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">"/"</span> + scanPackage.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>));</span><br><span class="line">    <span class="comment">//获取File文件</span></span><br><span class="line">    File classPath = <span class="keyword">new</span> File(url.getFile());</span><br><span class="line">    <span class="comment">//循环文件路径，获取下面的子文件（文件架）</span></span><br><span class="line">    <span class="keyword">for</span> (File file : classPath.listFiles()) &#123;</span><br><span class="line">        <span class="comment">//如果是文件夹，递归</span></span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            doScanner(scanPackage + <span class="string">"."</span> + file.getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果是文件，判断是否是class文件</span></span><br><span class="line">            <span class="keyword">if</span> (!file.getName().endsWith(<span class="string">".class"</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去掉后缀，将文件的全路径名存入数组</span></span><br><span class="line">            classNames.add(scanPackage + <span class="string">"."</span> + file.getName().replace(<span class="string">".class"</span>, <span class="string">""</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>扫描到的类实例化。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (classNames.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//循环扫描的类名称</span></span><br><span class="line">         <span class="keyword">for</span> (String className : classNames) &#123;</span><br><span class="line">             <span class="comment">//反射获取Class</span></span><br><span class="line">             Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">             <span class="comment">//如果注解是controller</span></span><br><span class="line">             <span class="keyword">if</span> (clazz.isAnnotationPresent(MyController<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                 <span class="comment">//获取实例</span></span><br><span class="line">                 Object instance = clazz.newInstance();</span><br><span class="line">                 <span class="comment">//获取类名首字母小写</span></span><br><span class="line">                 String beanName = toLowerFirstCase(clazz.getSimpleName());</span><br><span class="line">                 <span class="comment">//将类名作为key,类实例做为value存入map(ioc容器)</span></span><br><span class="line">                 ioc.put(beanName, instance);</span><br><span class="line">                 <span class="comment">//注解是service</span></span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz.isAnnotationPresent(MyService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                 <span class="comment">//获取注解内的名称</span></span><br><span class="line">                 String beanName = clazz.getAnnotation(MyService<span class="class">.<span class="keyword">class</span>).<span class="title">value</span>()</span>;</span><br><span class="line">                 <span class="comment">//注解内没有名称，类名为clazz的首字母小写类名</span></span><br><span class="line">                 <span class="keyword">if</span> (<span class="string">""</span>.equals(beanName.trim())) &#123;</span><br><span class="line">                     beanName = toLowerFirstCase(clazz.getSimpleName());</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//获取内的实例</span></span><br><span class="line">                 Object instance = clazz.newInstance();</span><br><span class="line">                 <span class="comment">//将类名作为key,类实例做为value存入map(ioc容器)</span></span><br><span class="line">                 ioc.put(beanName, instance);</span><br><span class="line">                 <span class="comment">//循环获取class的所有接口</span></span><br><span class="line">                 <span class="keyword">for</span> (Class&lt;?&gt; i : clazz.getInterfaces()) &#123;</span><br><span class="line">                     <span class="comment">//如果接口有多个实现类，报异常</span></span><br><span class="line">                     <span class="keyword">if</span> (ioc.containsKey(i.getName())) &#123;</span><br><span class="line">                         <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"The "</span> + i.getName() + <span class="string">" is exists!!"</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">//否则将接口作为key，实例作为value存入map</span></span><br><span class="line">                     ioc.put(i.getName(), instance);</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//没有注解，跳出，下一个</span></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> String <span class="title">toLowerFirstCase</span><span class="params">(String simpleName)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span>[] chars = simpleName.toCharArray();</span><br><span class="line">     chars[<span class="number">0</span>] += <span class="number">32</span>;</span><br><span class="line">     <span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>将扫描到的类的所有属性进行依赖注入。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAutowired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ioc.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环ioc容器</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : ioc.entrySet()) &#123;</span><br><span class="line">        <span class="comment">//获取value的所有的 private/protected/default/public 修饰字段</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : entry.getValue().getClass().getDeclaredFields()) &#123;</span><br><span class="line">            <span class="comment">//没有MyAutowired的注解不管</span></span><br><span class="line">            <span class="keyword">if</span> (!field.isAnnotationPresent(MyAutowired<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            MyAutowired autowired = field.getAnnotation(MyAutowired<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            String beanName = autowired.value().trim();</span><br><span class="line">            <span class="comment">//如果注解内没有value,beanName就为字段的类型</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">""</span>.equals(beanName.trim())) &#123;</span><br><span class="line">                beanName = field.getType().getName();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//暴力访问</span></span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//将这个字段注入到这个类中</span></span><br><span class="line">                field.set(entry.getValue(), ioc.get(beanName));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>获取类的方法和方法的url参数，存入handlerMapping中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInitHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ioc.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环ioc容器</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : ioc.entrySet()) &#123;</span><br><span class="line">        <span class="comment">//获取value（Object）的class</span></span><br><span class="line">        Class&lt;?&gt; clazz = entry.getValue().getClass();</span><br><span class="line">        <span class="comment">//如果这个类没有controller注解，不管它</span></span><br><span class="line">        <span class="keyword">if</span> (!clazz.isAnnotationPresent(MyController<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取controller上面的url</span></span><br><span class="line">        String baseUrl = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (clazz.isAnnotationPresent(MyRequestMapping<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            MyRequestMapping requestMapping = clazz.getAnnotation(MyRequestMapping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            baseUrl = requestMapping.value();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取class的所有方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : clazz.getMethods()) &#123;</span><br><span class="line">            <span class="comment">//没有MyRequestMapping注解的方法不管</span></span><br><span class="line">            <span class="keyword">if</span> (!method.isAnnotationPresent(MyRequestMapping<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            MyRequestMapping requestMapping = method.getAnnotation(MyRequestMapping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            String url = (<span class="string">"/"</span> + baseUrl + <span class="string">"/"</span> + requestMapping.value()).replaceAll(<span class="string">"/+"</span>, <span class="string">"/"</span>);</span><br><span class="line">            <span class="comment">//将url作为key,方法作为value存入handlerMapping中</span></span><br><span class="line">            handlerMapping.put(url, method);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Map :"</span> + url + <span class="string">","</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h5><ol>
<li>根据 请求url 从 handlerMapping 获取方法，2. 获取请求参数，3. 调用请求。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String url = req.getRequestURI();</span><br><span class="line">    String contextPath = req.getContextPath();</span><br><span class="line">    url = url.replaceAll(contextPath, <span class="string">""</span>).replaceAll(<span class="string">"/+"</span>, <span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.handlerMapping.containsKey(url)) &#123;</span><br><span class="line">        resp.getWriter().write(<span class="string">"404 not found!!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String[]&gt; params = req.getParameterMap();</span><br><span class="line">    <span class="comment">//根据url获取方法</span></span><br><span class="line">    Method method = <span class="keyword">this</span>.handlerMapping.get(url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取形参列表</span></span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">    <span class="comment">//获取参数类型</span></span><br><span class="line">    Object[] paramValues = <span class="keyword">new</span> Object[parameterTypes.length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">        Class paramterType = parameterTypes[i];</span><br><span class="line">        <span class="keyword">if</span> (paramterType == HttpServletRequest<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            paramValues[i] = req;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (paramterType == HttpServletResponse<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            paramValues[i] = resp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (paramterType == String<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//通过运行时的状态去拿到你</span></span><br><span class="line">            Annotation[][] pa = method.getParameterAnnotations();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pa.length; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Annotation a : pa[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a <span class="keyword">instanceof</span> MyRequestParam) &#123;</span><br><span class="line">                        String paramName = ((MyRequestParam) a).value();</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="string">""</span>.equals(paramName.trim())) &#123;</span><br><span class="line">                            String value = Arrays.toString(params.get(paramName))</span><br><span class="line">                                    .replaceAll(<span class="string">"\\[|\\]"</span>, <span class="string">""</span>)</span><br><span class="line">                                    .replaceAll(<span class="string">"\\s+"</span>, <span class="string">","</span>);</span><br><span class="line">                            paramValues[i] = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String beanName = toLowerFirstCase(method.getDeclaringClass().getSimpleName());</span><br><span class="line">    <span class="comment">//反射调用方法</span></span><br><span class="line">    method.invoke(ioc.get(beanName), paramValues);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    最后来结合整体思路来看看总体代码：</p>
<p><img src="https://img-blog.csdnimg.cn/20200402171815867.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW50aWFubHVu,size_16,color_FFFFFF,t_70" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alan.mvcframework.annotation.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDispatchServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Properties contextConfig = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">//存扫描的类</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; classNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">//IOC容器</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    <span class="comment">//handlerMapping存url和method</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Method&gt; handlerMapping = <span class="keyword">new</span> HashMap&lt;String, Method&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//委派，根据url去找到一个对应的Method，然后通过response返回</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doDispatch(req, resp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            resp.getWriter().write(<span class="string">"500 Exception,Detail :"</span> + Arrays.toString(e.getStackTrace()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String url = req.getRequestURI();</span><br><span class="line">        String contextPath = req.getContextPath();</span><br><span class="line">        url = url.replaceAll(contextPath, <span class="string">""</span>).replaceAll(<span class="string">"/+"</span>, <span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.handlerMapping.containsKey(url)) &#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">"404 not found!!"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String[]&gt; params = req.getParameterMap();</span><br><span class="line">        <span class="comment">//根据url获取方法</span></span><br><span class="line">        Method method = <span class="keyword">this</span>.handlerMapping.get(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取形参列表</span></span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="comment">//获取参数类型</span></span><br><span class="line">        Object[] paramValues = <span class="keyword">new</span> Object[parameterTypes.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">            Class paramterType = parameterTypes[i];</span><br><span class="line">            <span class="keyword">if</span> (paramterType == HttpServletRequest<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                paramValues[i] = req;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (paramterType == HttpServletResponse<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                paramValues[i] = resp;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (paramterType == String<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="comment">//通过运行时的状态去拿到你</span></span><br><span class="line">                Annotation[][] pa = method.getParameterAnnotations();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pa.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Annotation a : pa[i]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> MyRequestParam) &#123;</span><br><span class="line">                            String paramName = ((MyRequestParam) a).value();</span><br><span class="line">                            <span class="keyword">if</span> (!<span class="string">""</span>.equals(paramName.trim())) &#123;</span><br><span class="line">                                String value = Arrays.toString(params.get(paramName))</span><br><span class="line">                                        .replaceAll(<span class="string">"\\[|\\]"</span>, <span class="string">""</span>)</span><br><span class="line">                                        .replaceAll(<span class="string">"\\s+"</span>, <span class="string">","</span>);</span><br><span class="line">                                paramValues[i] = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String beanName = toLowerFirstCase(method.getDeclaringClass().getSimpleName());</span><br><span class="line">        <span class="comment">//反射调用方法</span></span><br><span class="line">        method.invoke(ioc.get(beanName), paramValues);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// 加载配置文件,获取web.xml里面init-param的param-name,作为参数传递</span></span><br><span class="line">        doLoadConfig(config.getInitParameter(<span class="string">"contextConfigLocation"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描所有的类,传入配置的扫描包路径</span></span><br><span class="line">        doScanner(contextConfig.getProperty(<span class="string">"scanPackage"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将类的实例存入IOC容器</span></span><br><span class="line">        doInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//DI 依赖注入</span></span><br><span class="line">        doAutowired();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化handlerMapping</span></span><br><span class="line">        doInitHandlerMapping();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInitHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ioc.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环ioc容器</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : ioc.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//获取value（Object）的class</span></span><br><span class="line">            Class&lt;?&gt; clazz = entry.getValue().getClass();</span><br><span class="line">            <span class="comment">//如果这个类没有controller注解，不管它</span></span><br><span class="line">            <span class="keyword">if</span> (!clazz.isAnnotationPresent(MyController<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取controller上面的url</span></span><br><span class="line">            String baseUrl = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(MyRequestMapping<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                MyRequestMapping requestMapping = clazz.getAnnotation(MyRequestMapping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                baseUrl = requestMapping.value();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取class的所有方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : clazz.getMethods()) &#123;</span><br><span class="line">                <span class="comment">//没有MyRequestMapping注解的方法不管</span></span><br><span class="line">                <span class="keyword">if</span> (!method.isAnnotationPresent(MyRequestMapping<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                MyRequestMapping requestMapping = method.getAnnotation(MyRequestMapping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                String url = (<span class="string">"/"</span> + baseUrl + <span class="string">"/"</span> + requestMapping.value()).replaceAll(<span class="string">"/+"</span>, <span class="string">"/"</span>);</span><br><span class="line">                <span class="comment">//将url作为key,方法作为value存入handlerMapping中</span></span><br><span class="line">                handlerMapping.put(url, method);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"Map :"</span> + url + <span class="string">","</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAutowired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ioc.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环ioc容器</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : ioc.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//获取value的所有的 private/protected/default/public 修饰字段</span></span><br><span class="line">            <span class="keyword">for</span> (Field field : entry.getValue().getClass().getDeclaredFields()) &#123;</span><br><span class="line">                <span class="comment">//没有MyAutowired的注解不管</span></span><br><span class="line">                <span class="keyword">if</span> (!field.isAnnotationPresent(MyAutowired<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                MyAutowired autowired = field.getAnnotation(MyAutowired<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                String beanName = autowired.value().trim();</span><br><span class="line">                <span class="comment">//如果注解内没有value,beanName就为字段的类型</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">""</span>.equals(beanName.trim())) &#123;</span><br><span class="line">                    beanName = field.getType().getName();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//暴力访问</span></span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//将这个字段注入到这个类中</span></span><br><span class="line">                    field.set(entry.getValue(), ioc.get(beanName));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (classNames.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//循环扫描的类名称</span></span><br><span class="line">            <span class="keyword">for</span> (String className : classNames) &#123;</span><br><span class="line">                <span class="comment">//反射获取Class</span></span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">                <span class="comment">//如果注解是controller</span></span><br><span class="line">                <span class="keyword">if</span> (clazz.isAnnotationPresent(MyController<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    <span class="comment">//获取实例</span></span><br><span class="line">                    Object instance = clazz.newInstance();</span><br><span class="line">                    <span class="comment">//获取类名首字母小写</span></span><br><span class="line">                    String beanName = toLowerFirstCase(clazz.getSimpleName());</span><br><span class="line">                    <span class="comment">//将类名作为key,类实例做为value存入map(ioc容器)</span></span><br><span class="line">                    ioc.put(beanName, instance);</span><br><span class="line">                    <span class="comment">//注解是service</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz.isAnnotationPresent(MyService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    <span class="comment">//获取注解内的名称</span></span><br><span class="line">                    String beanName = clazz.getAnnotation(MyService<span class="class">.<span class="keyword">class</span>).<span class="title">value</span>()</span>;</span><br><span class="line">                    <span class="comment">//注解内没有名称，类名为clazz的首字母小写类名</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">""</span>.equals(beanName.trim())) &#123;</span><br><span class="line">                        beanName = toLowerFirstCase(clazz.getSimpleName());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//获取内的实例</span></span><br><span class="line">                    Object instance = clazz.newInstance();</span><br><span class="line">                    <span class="comment">//将类名作为key,类实例做为value存入map(ioc容器)</span></span><br><span class="line">                    ioc.put(beanName, instance);</span><br><span class="line">                    <span class="comment">//循环获取class的所有接口</span></span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;?&gt; i : clazz.getInterfaces()) &#123;</span><br><span class="line">                        <span class="comment">//如果接口有多个实现类，报异常</span></span><br><span class="line">                        <span class="keyword">if</span> (ioc.containsKey(i.getName())) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"The "</span> + i.getName() + <span class="string">" is exists!!"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//否则将接口作为key，实例作为value存入map</span></span><br><span class="line">                        ioc.put(i.getName(), instance);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//没有注解，跳出，下一个</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">toLowerFirstCase</span><span class="params">(String simpleName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = simpleName.toCharArray();</span><br><span class="line">        chars[<span class="number">0</span>] += <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doScanner</span><span class="params">(String scanPackage)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取classLoader下面该路径的url,由/拼接</span></span><br><span class="line">        URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">"/"</span> + scanPackage.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>));</span><br><span class="line">        <span class="comment">//获取File文件</span></span><br><span class="line">        File classPath = <span class="keyword">new</span> File(url.getFile());</span><br><span class="line">        <span class="comment">//循环文件路径，获取下面的子文件（文件架）</span></span><br><span class="line">        <span class="keyword">for</span> (File file : classPath.listFiles()) &#123;</span><br><span class="line">            <span class="comment">//如果是文件夹，递归</span></span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                doScanner(scanPackage + <span class="string">"."</span> + file.getName());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是文件，判断是否是class文件</span></span><br><span class="line">                <span class="keyword">if</span> (!file.getName().endsWith(<span class="string">".class"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//去掉后缀，将文件的全路径名存入数组</span></span><br><span class="line">                classNames.add(scanPackage + <span class="string">"."</span> + file.getName().replace(<span class="string">".class"</span>, <span class="string">""</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doLoadConfig</span><span class="params">(String contextConfigLocation)</span> </span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(contextConfigLocation);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//存入一个property里面</span></span><br><span class="line">            contextConfig.load(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】单例模式</title>
    <url>/2019/05/02/6/</url>
    <content><![CDATA[<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>​    单例模式是指一个类在任何情况下，都只有一个实例。它提供了一个全局的访问点。</p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><h5 id="1-饿汉式单例模式"><a href="#1-饿汉式单例模式" class="headerlink" title="1.饿汉式单例模式"></a>1.饿汉式单例模式</h5><p>​    饿汉式单例模式提供了final修饰的静态变量，所以在类加载的过程中，在加载到变量的时候就进行了初始化的操作。而不管创建后是不是要使用这个类。给人一种比较饥饿的感觉，所以就叫它饿汉式的单例模式。而且，由于在线程访问它之前，就进行了初始化，所以它就不会出现线程安全的问题，因而它是绝对线程安全的一种单例模式。</p>
<p>​    饿汉式单例模式的优点是它没有加任何锁，它的执行效率比较高，用户体验也比懒汉式单例模式好。缺点是，当要创建成单例模式的类非常多，而有些类又不会被用到的时候，就会非常的浪费内存。</p>
<p>1.1 简单的饿汉式单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySimpleSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySimpleSingleton instance = <span class="keyword">new</span> HungrySimpleSingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySimpleSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySimpleSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.2 包含静态代码块的饿汉式单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式单例模式（带静态代码块的）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungryStaticSimpleSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  HungryStaticSimpleSingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> HungryStaticSimpleSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungryStaticSimpleSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungryStaticSimpleSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    饿汉式单例模式适用于单例对象比较少的时候，为了解决内存浪费的问题，就需要用到下面的懒汉式单例模式。</p>
<h5 id="2-懒汉式单例模式"><a href="#2-懒汉式单例模式" class="headerlink" title="2.懒汉式单例模式"></a>2.懒汉式单例模式</h5><p>​    懒汉式单例模式的特点是当外部需要用到的时候才会初始化，否则就不会初始化。</p>
<p>2.1 简单的懒汉式单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySimpleSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySimpleSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySimpleSingleton lazySimpleSingleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySimpleSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lazySimpleSingleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            lazySimpleSingleton = <span class="keyword">new</span> LazySimpleSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazySimpleSingleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    但是这种写法也会有弊端：它会出现线程安全的问题。例如现在试着创建两个线程，然后在两个线程中创建类的实例，两个线程同时启动，看看它们创建的实例是不是同一个。</p>
<p>​    写一个线程类，然后打印出当前线程的名字和单例的内存地址值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在线程池中创建懒汉式实例，打印出当前线程和懒汉式实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExectorThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LazySimpleSingleton lazySimpleSingleton = LazySimpleSingleton.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + lazySimpleSingleton );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在客户端进行测试，创建两个线程同时启动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式客户端测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySimpleSingltonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ExectorThread());</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ExectorThread());</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过最后的结果会发现，在某些情况下，两个单例的地址值并不相同。这是因为，当两个线程同时走到getInstance方法的if判断这里时，因为两个单例实例这个时候都为null，所以两个线程的非空判断都会为true，这个时候继续往下走，就会同时创建两个不同的实例对象。这样就违背了单例模式任何时候都只能有一个实例的定义。这就意味着上面的懒汉式单例模式的写法会出现线程安全的问题。</p>
<p><img src="https://img-blog.csdnimg.cn/20200306220714808.jpg" alt></p>
<p>2.2 线程安全的懒汉式单例模式</p>
<p>​    因此需要在获取实例的getInstance方法上加入关键字synchronized,这样获取实例的方法就变成了同步方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式单例模式（线程安全）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySimpleSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySimpleSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySimpleSingleton lazySimpleSingleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySimpleSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lazySimpleSingleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            lazySimpleSingleton = <span class="keyword">new</span> LazySimpleSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazySimpleSingleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过对线程进行debug调试发现，当第一个线程进入同步方法中时，另一个方法的状态会由running变成monitor。只有等第一个线程走出这个同步方法时，第二个线程才可以继续执行，否则它会一直处于监听的状态。</p>
<p><img src="https://img-blog.csdnimg.cn/20200306223436179.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW50aWFubHVu,size_16,color_FFFFFF,t_70" alt></p>
<p>​    这样就保证了实例只会被创建一次，就解决了线程安全的问题。但是如果在线程很多的情况下，cpu的分配压力会变大，大量的线程阻塞会影响程序的效率和性能。那么，为了解决线程安全和线程安全导致效率低下的问题，就出现了下面的解决方法-双重检查锁的单例模式。</p>
<p> 2.3 双重检查锁的懒汉式单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查索懒汉式单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckSimple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyDoubleCheckSimple singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckSimple</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckSimple <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyDoubleCheckSimple<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> LazyDoubleCheckSimple();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    去掉了在getInstance方法上syncronized修饰符，转而在非空的判断里面加上同步代码块。这样所有的线程就可以进入到非空判断的里面，而不是在外面阻塞住。而且因为在同步代码块内部又加上了一层非空判断，所以最后也能保证不会创建两个相同的实例。这样在保证线程安全的情况下，就相对提高了程序的性能。可是由于加上了锁，终归还是会存在性能问题，那么有没有更好的解决方案呢。</p>
<p>​    这时候，就出现了静态内部类的懒汉式单例模式。</p>
<p>2.4 静态内部类的懒汉式单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类懒汉式单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInnerClassSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyInnerClassSingleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyInnerClassSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.LAZY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyInnerClassSingleton LAZY = <span class="keyword">new</span> LazyInnerClassSingleton();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这种方式是从类的初始化的角度看的，只有在调用getInstance方法时，才会初始化内部类，然后获取到实例对象。如果不调用，就不会初始化内部类。这就解决了饿汉式单例模式的内存浪费和因为同步而带来的性能底下的问题。</p>
<p>​    但是以上的单例模式写法是不是又是完美的呢？下面我们来试图用反射，尝试一下破坏单例。通过反射获取单例类的私有化构造方法，然后通过设施setAccesible的方法为true暴力访问。然后调用两次newInstance方法，看创建的两个对象是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过暴力访问，破坏单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInnerSingletonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class&lt;?&gt; clazz = LazyInnerClassSingleton<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            Constructor&lt;?&gt; c = clazz.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            c.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            Object o1 = c.newInstance();</span><br><span class="line">            Object o2 = c.newInstance();</span><br><span class="line"></span><br><span class="line">            System.out.println(o1 == o2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    发现两个对象是不相等的，说明这种单例已经被反射暴力的破坏了。</p>
<p><img src="https://img-blog.csdnimg.cn/20200308135257981.jpg" alt></p>
<p>2.5 防止反射破坏的静态内部类单例模式</p>
<p>​    那么现在来优化一下代码。在构造方法的内部，对静态内部类的LAZY单例对象进行非空的校验，如果不为空，说明已经被创建了，就抛出异常。不允许它被创建两次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类懒汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInnerClassSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyInnerClassSingleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyInnerClassSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(LazyHolder.LAZY != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不允许创建多个实例"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyInnerClassSingleton LAZY = <span class="keyword">new</span> LazyInnerClassSingleton();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    再次运行测试代码，会发现一个运行时异常被抛出了，就是自己在非空校验中抛出的异常。</p>
<p><img src="https://img-blog.csdnimg.cn/20200308140611264.jpg" alt></p>
<p>2.6 防止序列化破坏的单例模式</p>
<p>​    一个单例对象创建好了之后，有时候需要将对象序列化的写入到磁盘中，下次再使用就从磁盘中读取对象并反序列化，将其转换为内存对象。反序列化后的对象将会重新分配内存，就是重新创建对象。如果这个序列化的对象是单例的，那么就违背了单例模式只能有一个实例的初衷。那么这个单例对象就会被序列化破坏。比如之前的懒汉式单例模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeralizeSingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SeralizeSingleton singleton = <span class="keyword">new</span> SeralizeSingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SeralizeSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SeralizeSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    现在来创建测试例子，看看序列化的单例模式如何被破坏了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerealizesingletonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SeralizeSingleton s1 = <span class="keyword">null</span>;</span><br><span class="line">        SeralizeSingleton s2 = SeralizeSingleton.getInstance();</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"SeralizeSingleton.obj"</span>);</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">            oos.writeObject(s2);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"SeralizeSingleton.obj"</span>);</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">            Object o = ois.readObject();</span><br><span class="line">            s1 = (SeralizeSingleton) o;</span><br><span class="line">            ois.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(s1);</span><br><span class="line">            System.out.println(s2);</span><br><span class="line">            System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    看看最后的结果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200308152903811.png" alt></p>
<p>​    由于将单例对象反序列化后重新了对象，重新分配了地址值，所以两个对象是不相等的。那么如何防止序列破坏单例模式呢，其实只需要加上readResolve方法就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeralizeSingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SeralizeSingleton singleton = <span class="keyword">new</span> SeralizeSingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SeralizeSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SeralizeSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    再看看运行的结果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200308153531415.jpg" alt></p>
<p>​    那么，为什么加上readResolve方法后，出现的两个对象就相同了呢？这里就需要打开源码，去看看ObjectInputStream的readObject方法了。在readObject方法里面可以找到一个重写的方法readObject0。</p>
<p>​    <img src="https://img-blog.csdnimg.cn/20200308161239330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW50aWFubHVu,size_16,color_FFFFFF,t_70" alt></p>
<p>​    然后点开这个readObject0，找到checkResolve方法，点击里面的readOrdinaryObject方法。</p>
<p><img src="https://img-blog.csdnimg.cn/20200308155413736.jpg" alt></p>
<p>​    会发现，在这里一个判断，hasReadResolveMethod()，如果有readResolve这个方法，就会返回true。接着，就会调用invokeReadResolve方法，传入obj（就是要读的对象），然后将值赋给rep，然后将rep的值赋给obj，然后返回。实际上，这个过程就是，判断是否有readResolve方法，如果有就返回obj它自己，如果没有，通过下面的代码可以看到，它就会创建一个新的实例。所以如果在类中写了readResolve方法，就能够防止序列化破坏单例模式。</p>
<p>​    <img src="https://img-blog.csdnimg.cn/20200308160724401.jpg" alt></p>
<p>​    通过jdk的源码我们可以看出，虽然增加readResolve（）方法能够防止序列化破坏单例模式，但是实际上，单例还是被创建了两次，只是没有被返回而已。如果创建对象发生的次数过于频繁，那么内存的开销也会变大。难道就没有办法从根本上解决问题了吗?下面的注册式单例也许就可以解决这个问题。</p>
<h5 id="3-注册式单例模式"><a href="#3-注册式单例模式" class="headerlink" title="3 注册式单例模式"></a>3 注册式单例模式</h5><p>3.1 枚举式单例模式</p>
<p>​    先看看代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举式单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    写测试类，测试反序列化是否会破坏单例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSingletonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            EnumSingleton s1 = <span class="keyword">null</span>;</span><br><span class="line">            EnumSingleton s2 = EnumSingleton.getInstance();</span><br><span class="line">            s2.setData(<span class="keyword">new</span> Object());</span><br><span class="line"></span><br><span class="line">            FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"EnumSingleton.obj"</span>);</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">            oos.writeObject(s2);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"EnumSingleton.obj"</span>);</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">            s1 = (EnumSingleton) ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(s1.getData());</span><br><span class="line">            System.out.println(s2.getData());</span><br><span class="line">            System.out.println(s1.getData() == s2.getData());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    看看最后的结果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200309155311615.jpg" alt></p>
<p>​    可以看到，反序列化并不会破坏枚举式单例。</p>
<p>3.2 容器式单例模式</p>
<p>​    容器式单例模式是创建一个拥有静态Map容器的类，然后提供一个根据类名获取类的实例的方法。如果容易里面找不到这个实例，就新创建。如果找的到就将实例返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容器式单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ContainerSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; ioc = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String className)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ioc)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!ioc.containsKey(className))&#123;</span><br><span class="line">                Object obj = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//通过反射获取对象的实例，然后创建对象</span></span><br><span class="line">                    obj = Class.forName(className).newInstance();</span><br><span class="line">                    ioc.put(className,obj);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ioc.get(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这种容器式单例模式适用于实例比较多的情况，比较的方便管理，它是线程不安全的单例模式。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【spring5源码分析】IoC部分</title>
    <url>/2019/07/08/14/</url>
    <content><![CDATA[<h5 id="定位阶段"><a href="#定位阶段" class="headerlink" title="定位阶段"></a>定位阶段</h5><p>​    1. 构造器中初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">super</span>(parent);</span><br><span class="line">	setConfigLocations(configLocations);</span><br><span class="line">	<span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">		refresh();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用 setConfigLocations()，解析定义资源文件的路径，将其保存到字符串数组。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析Bean定义资源文件的路径，处理多个资源文件字符串数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(@Nullable String... locations)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Assert.noNullElements(locations, <span class="string">"Config locations must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line">			<span class="comment">// resolvePath为同一个类中将字符串解析为路径的方法</span></span><br><span class="line">			<span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用 refresh()，启动容器。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">		<span class="comment">//1、调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识</span></span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">		<span class="comment">//2、告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从</span></span><br><span class="line">		<span class="comment">//子类的refreshBeanFactory()方法启动</span></span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">		<span class="comment">//3、为BeanFactory配置容器特性，例如类加载器、事件处理器等</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">			<span class="comment">//4、为容器的某些子类指定特殊的BeanPost事件处理器</span></span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">			<span class="comment">//5、调用所有注册的BeanFactoryPostProcessor的Bean</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">			<span class="comment">//6、为BeanFactory注册BeanPost事件处理器.</span></span><br><span class="line">			<span class="comment">//BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">			<span class="comment">//7、初始化信息源，和国际化相关.</span></span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">			<span class="comment">//8、初始化容器事件传播器.</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">			<span class="comment">//9、调用子类的某些特殊Bean初始化方法</span></span><br><span class="line">			onRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">			<span class="comment">//10、为事件传播器注册事件监听器.</span></span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">			<span class="comment">//11、初始化所有剩余的单例Bean</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">			<span class="comment">//12、初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">						<span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">			<span class="comment">//13、销毁已创建的Bean</span></span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Reset 'active' flag.</span></span><br><span class="line">			<span class="comment">//14、取消refresh操作，重置容器的同步标识。</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">			<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">			<span class="comment">//15、重设公共缓存</span></span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 refresh() 中，调用 AbstractApplicationContext 类的 obtainFreshBeanFactory() 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法</span></span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用委派模式，在子类中调用 refreshBeanFactory() 方法，启动beanFactory。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="comment">//如果已经有容器，销毁容器中的bean，关闭容器</span></span><br><span class="line">	<span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">		destroyBeans();</span><br><span class="line">		closeBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//创建IOC容器</span></span><br><span class="line">		DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">		beanFactory.setSerializationId(getId());</span><br><span class="line">		<span class="comment">//对IOC容器进行定制化，如设置启动参数，开启注解的自动装配等</span></span><br><span class="line">		customizeBeanFactory(beanFactory);</span><br><span class="line">		<span class="comment">//调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器</span></span><br><span class="line">		loadBeanDefinitions(beanFactory);</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">			<span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h5><ol start="6">
<li>使用委派模式，调用 loadBeanDefinitions() 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现父类抽象的载入Bean定义方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">	<span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">	<span class="comment">//创建XmlBeanDefinitionReader，即创建Bean读取器，并通过回调设置到容器中去，容  器使用该读取器读取Bean定义资源</span></span><br><span class="line">	XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line">	<span class="comment">// resource loading environment.</span></span><br><span class="line">	<span class="comment">//为Bean读取器设置Spring资源加载器，AbstractXmlApplicationContext的</span></span><br><span class="line">	<span class="comment">//祖先父类AbstractApplicationContext继承DefaultResourceLoader，因此，容器本身也是一个资源加载器</span></span><br><span class="line">	beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">	beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">	<span class="comment">//为Bean读取器设置SAX xml解析器</span></span><br><span class="line">	beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">	<span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">	<span class="comment">//当Bean读取器读取Bean定义的Xml资源文件时，启用Xml的校验机制</span></span><br><span class="line">	initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">	<span class="comment">//Bean读取器真正实现加载的方法</span></span><br><span class="line">	loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>调用自己的 loadBeanDefinitions() 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">	<span class="comment">//获取Bean定义资源的定位</span></span><br><span class="line">	Resource[] configResources = getConfigResources();</span><br><span class="line">	<span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位</span></span><br><span class="line">		<span class="comment">//的Bean定义资源</span></span><br><span class="line">		reader.loadBeanDefinitions(configResources);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果子类中获取的Bean定义资源定位为空，则获取FileSystemXmlApplicationContext构造方法中setConfigLocations方法设置的资源</span></span><br><span class="line">	String[] configLocations = getConfigLocations();</span><br><span class="line">	<span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位</span></span><br><span class="line">		<span class="comment">//的Bean定义资源</span></span><br><span class="line">		reader.loadBeanDefinitions(configLocations);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>调用 AbstractBeanDefinitionReader  类的 loadBeanDefinitions() 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	Assert.notNull(resources, <span class="string">"Resource array must not be null"</span>);</span><br><span class="line">	<span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">		counter += loadBeanDefinitions(resource);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>调用 XmlBeanDefinitionReader 类的 loadBeanDefinitions() 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里是载入XML形式Bean定义资源文件方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">		logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource.getResource());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">	<span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">		currentResources = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">		<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">				<span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//将资源文件转为InputStream的IO流</span></span><br><span class="line">		InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//从InputStream中得到XML的解析源</span></span><br><span class="line">			InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">			<span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//这里是具体的读取过程</span></span><br><span class="line">			<span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">//关闭从Resource中得到的IO流</span></span><br><span class="line">			inputStream.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">				<span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		currentResources.remove(encodedResource);</span><br><span class="line">		<span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>调用自己的 doLoadBeanDefinitions() 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从特定XML文件中实际载入Bean定义资源的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//将XML文件转换为DOM对象，解析过程由documentLoader实现</span></span><br><span class="line">		Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">		<span class="comment">//这里是启动对Bean定义解析的详细过程，该解析过程会用到Spring的Bean配置规则</span></span><br><span class="line">		<span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				<span class="string">"Line "</span> + ex.getLineNumber() + <span class="string">" in XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				<span class="string">"XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				<span class="string">"Parser configuration exception parsing XML from "</span> + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				<span class="string">"IOException parsing XML document from "</span> + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				<span class="string">"Unexpected exception parsing XML document from "</span> + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>调用自己的 registerBeanDefinitions() 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照Spring的Bean语义要求将Bean定义资源解析并转换为容器内部数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	<span class="comment">//得到BeanDefinitionDocumentReader来对xml格式的BeanDefinition解析</span></span><br><span class="line">	BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">	<span class="comment">//获得容器中注册的Bean数量</span></span><br><span class="line">	<span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">	<span class="comment">//解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口,</span></span><br><span class="line">	<span class="comment">//具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成</span></span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	<span class="comment">//统计解析的Bean数量</span></span><br><span class="line">	<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>调用 DefaultBeanDefinitionDocumentReader 类的 registerBeanDefinitions() 方法，根据Spring DTD对Bean的定义规则解析Bean定义Document对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获得XML描述符</span></span><br><span class="line">	<span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">	logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">	<span class="comment">//获得Document的根元素</span></span><br><span class="line">	Element root = doc.getDocumentElement();</span><br><span class="line">	doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>调用自己的 doRegisterBeanDefinitions() 方法。注册beanDefinition。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">	<span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">	<span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">	<span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">	<span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">	<span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//具体的解析过程由BeanDefinitionParserDelegate实现，</span></span><br><span class="line">	<span class="comment">//BeanDefinitionParserDelegate中定义了Spring Bean定义XML文件的各种元素</span></span><br><span class="line">	BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">	<span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">			String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">					profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">			<span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec +</span><br><span class="line">							<span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在解析Bean定义之前，进行自定义的解析，增强解析过程的可扩展性</span></span><br><span class="line">	preProcessXml(root);</span><br><span class="line">	<span class="comment">//从Document的根元素开始进行Bean定义的Document对象</span></span><br><span class="line">	parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">	<span class="comment">//在解析Bean定义之后，进行自定义的解析，增加解析过程的可扩展性</span></span><br><span class="line">	postProcessXml(root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注册阶段"><a href="#注册阶段" class="headerlink" title="注册阶段"></a>注册阶段</h5><ol start="14">
<li>调用 DefaultBeanDefinitionDocumentReader 类的 parseBeanDefinitions() 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the given bean element, parsing the bean definition</span></span><br><span class="line"><span class="comment"> * and registering it with the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析Bean定义资源Document对象的普通元素</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">	BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	<span class="comment">// BeanDefinitionHolder是对BeanDefinition的封装，即Bean定义的封装类</span></span><br><span class="line">	<span class="comment">//对Document对象中&lt;Bean&gt;元素的解析由BeanDefinitionParserDelegate实现</span></span><br><span class="line">	<span class="comment">// BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span></span><br><span class="line">	<span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">		bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Register the final decorated instance.</span></span><br><span class="line">			<span class="comment">//向Spring IOC容器注册解析得到的Bean定义，这是Bean定义向IOC容器注册的入口</span></span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">					bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Send registration event.</span></span><br><span class="line">		<span class="comment">//在完成向Spring IOC容器注册解析得到的Bean定义之后，发送注册事件</span></span><br><span class="line">		getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="15">
<li>调用 BeanDefinitionReaderUtils 的 registerBeanDefinition() 方法，将解析的BeanDefinitionHold注册到容器中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将解析的BeanDefinitionHold注册到容器中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">	<span class="comment">//获取解析的BeanDefinition的名称</span></span><br><span class="line">	String beanName = definitionHolder.getBeanName();</span><br><span class="line">	<span class="comment">//向IOC容器注册BeanDefinition</span></span><br><span class="line">	registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">	<span class="comment">//如果解析的BeanDefinition有别名，向容器为其注册别名</span></span><br><span class="line">	String[] aliases = definitionHolder.getAliases();</span><br><span class="line">	<span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">			registry.registerAlias(beanName, alias);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="16">
<li>向IoC容器注册BeanDefinition，将注册信息存入beanDefinitionMap 中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向IOC容器注册解析的BeanDefiniton</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">	Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//校验解析的BeanDefiniton</span></span><br><span class="line">	<span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">	oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">"Cannot register bean definition ["</span> + beanDefinition + <span class="string">"] for bean '"</span> + beanName +</span><br><span class="line">					<span class="string">"': There is already ["</span> + oldBeanDefinition + <span class="string">"] bound."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">			<span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.logger.warn(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName +</span><br><span class="line">						<span class="string">"' with a framework-generated bean definition: replacing ["</span> +</span><br><span class="line">						oldBeanDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.logger.info(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">						<span class="string">"' with a different definition: replacing ["</span> + oldBeanDefinition +</span><br><span class="line">						<span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.logger.debug(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">						<span class="string">"' with an equivalent definition: replacing ["</span> + oldBeanDefinition +</span><br><span class="line">						<span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">			<span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">			<span class="comment">//注册的过程中需要线程同步，以保证数据的一致性</span></span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">				updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">				updatedDefinitions.add(beanName);</span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">					Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">					updatedSingletons.remove(beanName);</span><br><span class="line">					<span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Still in startup registration phase</span></span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">			<span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检查是否有同名的BeanDefinition已经在IOC容器中注册</span></span><br><span class="line">	<span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">		<span class="comment">//重置所有已经注册过的BeanDefinition的缓存</span></span><br><span class="line">		resetBeanDefinition(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
