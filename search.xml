<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Bug】maven如何排除依赖</title>
    <url>/2019/04/10/1/</url>
    <content><![CDATA[<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>​    java.lang.IncompatibleClassChangeError: Found class org.objectweb.asm.MethodVisitor, but interface was expected at org.lilystudio.smarty4j.Template.toParser(Template.java:357)</p>
<p>java.lang.IncompatibleClassChangeError: Found class org.objectweb.asm.MethodVisitor, but interface was expected at org.lilystudio.smarty4j.Template.toParser(Template.java:357) at org.lilystudio.smarty4j.Template.<init>(Template.java:134) at org.lilystudio.smarty4j.Template.<init>(Template.java:152) at org.lilystudio.smarty4j.Engine.getTemplate(Engine.java:317) at com.doit.framework.mvc.core.Doit.render(Doit.java:769) at com.doit.framework.mvc.core.Doit.forwardTo(Doit.java:711) at com.doit.framework.mvc.core.Doit.doPost(Doit.java:286) at com.doit.framework.mvc.core.Doit.doGet(Doit.java:83) at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at com.doit.framework.mvc.filter.FrameServletFilter.doFilter(FrameServletFilter.java:30) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at com.doit.framework.mvc.filter.SetCharacterEncodingFilter.doFilter(SetCharacterEncodingFilter.java:32) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:493) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:137) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:660) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:798) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:808) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1498) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748)</init></init></p>
<h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>​    这个错误便表示使用jar包文件的依赖冲突引起的，仔细查看jar包，会发现有同一个jar的版本冲突：</p>
<p><img src="https://img-blog.csdnimg.cn/20190726102746100.jpg" alt></p>
<p><img src="https://img-blog.csdnimg.cn/20190726102814362.jpg" alt></p>
<p>​    在引入neo4j的jar包中，也包含了对 asm-6.2.jar 的引用。</p>
<h5 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h5><p>​    在neo4j的jar包中排除asm的依赖。  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.neo4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>neo4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Exclude asm --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ow2.asm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>asm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title>【软件设计原则】七大软件设计原则</title>
    <url>/2019/04/12/2/</url>
    <content><![CDATA[<h5 id="1-开闭原则：对扩展开放，对修改关闭。"><a href="#1-开闭原则：对扩展开放，对修改关闭。" class="headerlink" title="1.开闭原则：对扩展开放，对修改关闭。"></a>1.开闭原则：对扩展开放，对修改关闭。</h5><p>​    例子：咕泡课程：有java,前端，测试等等。每种课程有id,名称，价格。但是都不一样：新建一个抽象的接口Icouce，里面有三个方法，getid,getName,getPrice，新建一个javaCource，继承接口,重写三个方法。然后创建一个构造器。然后创建一个测试类，创建抽象接口的具体实现类，给属性赋值。然后就可以得到javaCouce的id,name,privce。 问题是现在课程可能会打折。所以就要创建一个javaDiscountCouse类在里面对price进行打折。这样就可以在获取折后价格的同时获取到原价了。</p>
<h5 id="2-依赖倒置原则："><a href="#2-依赖倒置原则：" class="headerlink" title="2.依赖倒置原则："></a>2.依赖倒置原则：</h5><p>​    高层模块不应该依赖底层模块。两者都应该依赖其抽象。抽象应该依赖细节，细节应该依赖抽象。针对接口编程，不针对实现编程。 可以减少类之间的耦合性，提高系统的稳定性。提高代码的可阅读性和可维护性，可以降低修改程序造成的风险。</p>
<h5 id="3-单一职责原则："><a href="#3-单一职责原则：" class="headerlink" title="3.单一职责原则："></a>3.单一职责原则：</h5><p>​    不要存在一个导致类变更的原因。一个类，接口，方法只负责一项职责。优点：降低类的耦合性，提高类的可阅读性，提高系统的可维护性，降低变更引起的风险。</p>
<h5 id="4-接口隔离原则："><a href="#4-接口隔离原则：" class="headerlink" title="4.接口隔离原则："></a>4.接口隔离原则：</h5><p>​    用多个单一的接口，而不是一个统一的接口。客户端不应该依赖不需要的接口。注意：一个类对应一个类的依赖应该建立在最小的接口上，建立单一的接口，不要建立庞大臃肿的解耦。尽量的细化接口，接口中的方法尽量的少。注意适度原则，一定要尽量的适度。</p>
<h5 id="5-迪米特法则："><a href="#5-迪米特法则：" class="headerlink" title="5.迪米特法则："></a>5.迪米特法则：</h5><p>​    一个对象应该对其他对象保持最少的了解，又叫最少知道原则。尽量降低类和类之间的耦合。强调只和朋友交流，不和陌生人说话。朋友，出现在成员变量，方法的输入输出参数中的类为成员朋友类，出现在方法体内部的类不是朋友类。</p>
<h5 id="6-里式替换原则："><a href="#6-里式替换原则：" class="headerlink" title="6.里式替换原则："></a>6.里式替换原则：</h5><p>​    如果每一个类型为T1的对象O1,都有类型为T2的对象O2,使得以T1定义的所有程序P在所有的对象O1都替换成O2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。定义扩展：一个软件实体如果适用一个父类的话，那一定适用于其子类，所有引用父类的地方必须能透明的使用其子类对象，子类对象能够替换父类对象，而程序逻辑不变。</p>
<p>​        引申意义：子类可以扩展父类的功能，但是不能改变父类的功能。</p>
<p>​        含义1：子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</p>
<p>​        含义2：子类中可以增加自己特有的方法。</p>
<p>​        含义3：当子类的方法重载父类的方法时，方法的前置条件（即方法的输入，入参）要比父类的输入参数要宽松。</p>
<p>​        含义4：当子类的方法实现父类的方法时（重写，重载或实现抽象的方法），方法的后置条件（即方法的输出，返回值）要比父类更严格或相等。</p>
<h5 id="7-合成，聚合复用原则："><a href="#7-合成，聚合复用原则：" class="headerlink" title="7.合成，聚合复用原则："></a>7.合成，聚合复用原则：</h5><p>​    尽量使用对象组合，聚合。而不是继承达到软件复用的目的。聚合has-a和组合contains-a 优点：可以是系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】工厂模式之简单工厂模式</title>
    <url>/2019/04/13/3/</url>
    <content><![CDATA[<h5 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a>1.定义：</h5><p>​    简单工厂模式是指由一个工厂决定创建哪一种产品类的实例。简单工厂模式适用于需要创建较少的产品实例。客户端在创建的时候，只需要传入创建的参数，不需要知道是如何创建的。</p>
<h5 id="2-举例："><a href="#2-举例：" class="headerlink" title="2.举例："></a>2.举例：</h5><p>​    2.1 场景：</p>
<p>​    有一个支付场景，支付的方式有多种，微信支付，阿里支付，银联支付。如何实现简单工厂模式。</p>
<p>​    2.2 步骤：</p>
<p>​    （1）.创建一个抽象的支付接口，只提供一个抽象的方法pay。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPay</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    (2) .创建一个工厂，用来生产各种支付方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPay <span class="title">create</span><span class="params">(Class&lt;? extends IPay&gt; clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(clazz != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    （3）.创建各种支付类，AliPay，WechatPay 等等，继承IPay接口，实现pay方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliPay</span> <span class="keyword">implements</span> <span class="title">IPay</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用支付宝付款"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatPay</span> <span class="keyword">implements</span> <span class="title">IPay</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用微信付款"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    （4）.在客服端new出一个工厂实例，根据需要传入具体要生产的是那种支付方式即可，这里传入的参数是类的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PayFactory payFactory = <span class="keyword">new</span> PayFactory();</span><br><span class="line"><span class="comment">//        IPay iPay = payFactory.create(AliPay.class);</span></span><br><span class="line">        IPay iPay = payFactory.create(WeChatPay<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        iPay.pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h5><p>​    如果以后出现了新的支付方式，我们不需要再去修改工厂里面的方法，只需要创建支付的实例类即可。这样就符合了软件设计的开闭原则，但是简单工厂模式也有它的缺点，以后如果支付的方式非常多，这个工厂的职责就会过重。所以简单工厂模式更适用于创建较少产品的场景，不适用于过于复杂的场景模式。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】工厂模式之工厂方法模式</title>
    <url>/2019/04/22/4/</url>
    <content><![CDATA[<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>​    工厂方法模式是指定义一个创建对象的接口，然后实现这个接口的工厂来决定创建什么样的实例。工厂方法让类的实例推迟到子类中进行。在这个模式中，只关心需要创建的是什么工厂，不需要关心创建的细节。而且新加入的产品符合开闭原则。</p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p>1.场景</p>
<p>​    有一个支付场景，支付的方式有多种，微信支付，阿里支付，银联支付。如何实现工厂方法模式。</p>
<p>2.步骤</p>
<p>（1） 创建支付接口，里面定义抽象的支付方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPay</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2） 创建工厂接口，提供创建的方法，返回支付接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPayFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">IPay <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3） 创建具体的支付类，AliPay,WechatPay,实现IPay接口，重写支付方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliPay</span> <span class="keyword">implements</span> <span class="title">IPay</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用支付宝支付"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.gupao.vip.pay.factorymethod;</span><br><span class="line"></span><br><span class="line">public class WechatPay implements IPay &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void pay() &#123;</span><br><span class="line">        System.out.println(&quot;用微信支付&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4） 创建微信支付和阿里支付的工厂类，继承抽象工厂，重写抽象工厂的create方法，返回具体的支付类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliPayFactory</span> <span class="keyword">implements</span> <span class="title">IPayFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPay <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AliPay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatPayFactory</span> <span class="keyword">implements</span> <span class="title">IPayFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPay <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WechatPay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5） 在客服端创建所需要的阿里支付和微信支付的工厂，然后由工厂来创建具体的支付类，然后就可以调用各自的支付方法了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IPayFactory aliPayFactory = <span class="keyword">new</span> AliPayFactory();</span><br><span class="line">        IPay aliPay = aliPayFactory.create();</span><br><span class="line">        aliPay.pay();</span><br><span class="line"></span><br><span class="line">        IPayFactory wechatPayFactory = <span class="keyword">new</span> WechatPayFactory();</span><br><span class="line">        IPay wwechatPay = wechatPayFactory.create();</span><br><span class="line">        wwechatPay.pay();</span><br><span class="line"></span><br><span class="line">        IPayFactory uniPayFactory = <span class="keyword">new</span> UniPayFactory();</span><br><span class="line">        IPay uniPay = uniPayFactory.create();</span><br><span class="line">        uniPay.pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>​    工厂方法模式只要解决了产品的扩展问题。在简单工厂中，如果在支付的同时需要加入其他的逻辑，而每个支付的逻辑都不一样，那么这个工厂的职责会变得非常的重。有点像万能工厂，不易于维护。而根据软件设计的单一职责原则，我们可以将工厂的职责拆分开来，专人干专事。阿里支付工厂就用来创建阿里支付，微信支付工厂就用来创建微信支付。</p>
<p>​    但同时这种设计模式也有它的缺点。它增加了类的创建个数，提升了系统的复杂度和可理解度。</p>
<p>​    所以，工厂方法模式适用的场景是：1.创建对象需要大量重复的代码。2.客服端（应用层）不依赖于产品的实例如何被创建。3.一个类是通过其子类来指定创建对象的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】工厂模式之抽象工厂模式</title>
    <url>/2019/04/24/5/</url>
    <content><![CDATA[<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>​    抽象工厂模式是指提供一系列相互依赖或者相关的接口，无需指定他们具体的类。客户端（应用层）不依赖于产品实例如何被创建的细节。强调的是一系列相关的产品对象一起使用创建对象需要大量重复的代码，需要提供一个产品类的库。所以的产品以同样的接口出现，从而使客户端不依赖于具体的实现。</p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><h5 id="1-1-场景"><a href="#1-1-场景" class="headerlink" title="1.1 场景"></a>1.1 场景</h5><p>​    有一个支付场景，要支付宝支付和微信支付，支付宝支付和微信支付都可以聊天，都可以借钱（假设）。</p>
<h5 id="1-2-步骤"><a href="#1-2-步骤" class="headerlink" title="1.2 步骤"></a>1.2 步骤</h5><p>（1） 创建抽象的聊天和借钱的接口，提供抽象的聊天和借钱的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITalk</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILend</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lend</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2） 创建支付的抽象 工厂类，提供公开的初始化方法，提供抽象的创造聊天和支付的方法，返回值是抽象的聊天和借钱。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PayFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"初始化数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ITalk <span class="title">createTalk</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ILend <span class="title">createLend</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliPayTalk</span> <span class="keyword">implements</span> <span class="title">ITalk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"支付宝聊天"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatTalk</span> <span class="keyword">implements</span> <span class="title">ITalk</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"微信可以聊天"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatLend</span> <span class="keyword">implements</span> <span class="title">ILend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"微信可以借钱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4） 创建阿里支付工厂和微信支付工厂，继承支付工厂接口，实现其抽象的方法。在方法中创建具体的聊天和借钱的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliPayFactory</span> <span class="keyword">extends</span> <span class="title">PayFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ITalk <span class="title">createTalk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AliPayTalk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ILend <span class="title">createLend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AliPayLend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatPayFactory</span> <span class="keyword">extends</span> <span class="title">PayFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ITalk <span class="title">createTalk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WechatTalk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ILend <span class="title">createLend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WechatLend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5） 在客户端创建支付宝支付和微信支付的工厂，调用工厂的创建聊天和借钱的接口创建具体的聊天和借钱的实例，最后调用聊天和借钱的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gupao.vip.pay.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AliPayFactory aliPayFactory = <span class="keyword">new</span> AliPayFactory();</span><br><span class="line">        aliPayFactory.createTalk().talk();</span><br><span class="line">        aliPayFactory.createLend().lend();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---------"</span>);</span><br><span class="line"></span><br><span class="line">        WechatPayFactory wechatPayFactory = <span class="keyword">new</span> WechatPayFactory();</span><br><span class="line">        wechatPayFactory.createTalk().talk();</span><br><span class="line">        wechatPayFactory.createLend().lend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>​    不知道大家有没有发现，如果在上面的代码中，需要给阿里支付和微信支付添加额外的功能，则需要改变抽象工厂和具体工厂的代码。这样就违背的软件设计的开闭原则。所以抽象工厂模式也是有缺点的。第一，产品族需要扩展功能很麻烦，需要修改抽象接口的代码。第二，创建的抽象类多，增加了系统的抽象性和理解难度。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
