[{"url":"/2020/04/15/【设计模式】享元模式/","content":"- # 定义\n\n​    享元模式又称为轻量级模式，是对象池的一种实现，类似于线程池。线程池可以避免重复的创建和销毁对象，消耗性能。提供了减少对象数量从而改善应用所需的对象结构的方式。其宗旨是共享细粒度对象，将对象的同意访问集中起来，不必为每一个访问者单独创建一个对象，以此来降低系统的消耗，属于结构型的模式。\n\n​    享元模式把对象的状态分为内部状态和外部状态，内部状态是不变的，外部状态是变化的；然后通过不变的部分，达到减少对象数量并减少内存的目的。\n\n- # 应用场景\n\n​    当系统中的多处需要一组信息，可以把这些信息封装到一个对象中，然后对对象进行缓存，这样，一个对象就可以提供给对多处访问。避免了多次使用同时创建对象，造成内存的消耗，影响性能。\n\n   享元模式其实就是工厂模式的一个改进机制，享元模式同样要求创建一个或一组对象，就是通过工厂方法生成对象的，只不过享元模式为工厂创建了一个缓存的功能。主要总结为一下的应用场景。\n\n   \\1. 常常应用于系统底层的开发，以便解决系统的性能。\n\n   \\2. 系统有大量的相似对象，需要缓冲池的场景。\n\n   在生活中的享元模式也很常见，比如各种中介和全国联网的医保。\n\n- # 例子\n\n​    生活中肯定会遇到要抢火车篇的情况。那些刷票软件实际上是将我们的信息保存下来，然后定时地去余票里面查询有没有自己需要的余票。假如一张火车票包含出发站，终点站，席次 的信息。然后这里写一个程序利用这些信息去查询有没有余票。\n\n   \\1. 创建ITicket接口，提供一个showInfo方法，传入席次信息\n\n```java\npublic interface ITicket {\n    void showInfo(String trunk);\n}\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n   \\2. 创建具体的TIcket类，继承ITicket接口，创建出发站，终点站和价格三个属性，重写showInfo方法，返回票的信息。\n\n```java\nimport java.util.Random;\n\npublic class Ticket implements ITicket {\n    private String from;\n    private String to;\n    private int price;\n\n    public Ticket(String from, String to) {\n        this.from = from;\n        this.to = to;\n    }\n\n    @Override\n    public void showInfo(String trunk) {\n        this.price = new Random().nextInt(500);\n        System.out.println(String.format(\"%s->%s:%s 价格：%s 元\", this.from, this.to, trunk, this.price));\n    }\n}\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n   \\3. 创建一个ticket工厂，提供静态的查询余票的方法，返回ITicket的抽象。\n\n```java\npublic class TicketFactory {\n\n    public static ITicket queryTicket(String from, String to) {\n        return new Ticket(from, to);\n    }\n}\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n   4.测试代码\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        ITicket iTicket = TicketFactory.queryTicket(\"杭州东\", \"汉口\");\n        iTicket.showInfo(\"硬座\");\n    }\n}\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n   5.查看结果\n\n![img](https://img-blog.csdnimg.cn/20200408115419411.jpg)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n   但是这样的写法其实也是每次去查询都创建了一个新的对象，那么其实可以改造一下。\n\n   6.改造TicketFactory工厂类，增加缓存机制，创建一个map容器保存对象，不存在才会去创建对象，存在就直接返回该对象。\n\n```java\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class TicketFactory {\n\n    private static Map<String, ITicket> sticketPool = new ConcurrentHashMap<>();\n\n    public static ITicket queryTicket(String from, String to) {\n        String key = from + \"->\" + to;\n        if (sticketPool.containsKey(key)) {\n            System.out.println(\"使用缓存: \" + key);\n            return TicketFactory.sticketPool.get(key);\n        }\n        System.out.println(\"首次查询，创建对象：\" + key);\n        ITicket iTicket = new Ticket(from, to);\n        TicketFactory.sticketPool.put(key,iTicket);\n        return iTicket;\n    }\n}\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n   7.重写测试方法。\n\n```java\npublic class Test {\n\n    public static void main(String[] args) {\n        ITicket iTicket = TicketFactory.queryTicket(\"孝感东\",\"汉口\");\n        iTicket.showInfo(\"上铺\");\n        iTicket = TicketFactory.queryTicket(\"孝感东\",\"汉口\");\n        iTicket.showInfo(\"上铺\");\n        iTicket = TicketFactory.queryTicket(\"杭州东\",\"汉口\");\n        iTicket.showInfo(\"中铺\");\n    }\n}\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n  \\8. 查看新的测试结果。\n\n![img](https://img-blog.csdnimg.cn/20200408143418462.jpg)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n- # 享元模式在源码中的应用\n\n​    来看看在Integer中，Integer是怎么将数据存在缓存中，然后从缓存中去取的。\n\n```java\npublic class Test1 {\n    public static void main(String[] args) {\n        Integer a = Integer.valueOf(100);\n        Integer b = 100;\n\n        Integer c = Integer.valueOf(1000);\n        Integer d = 1000;\n\n        System.out.println(\"a==b:\" + (a == b));\n        System.out.println(\"c==d:\" + (c == d));\n    }\n}\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n​    运行上面的代码，可以看到，a和b是相等的，c和d是不相等的。\n\n![img](https://img-blog.csdnimg.cn/20200408160700359.jpg)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n​    这是为什么呢，这里点开Integer的valueOf方法去看看。\n\n ![img](https://img-blog.csdnimg.cn/20200408160841432.jpg)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n   可以看到，如果传入的i值大于等于IntegerCache.low或者小于等于IntegerCache.high，那么就会从cha么就会从cache缓存里面取，如果不是的话就新建一个Integer对象。而IntegerCache.low的值是-128，IntegerCache.high的值是127。\n\n![img](https://img-blog.csdnimg.cn/20200408161245410.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n![img](https://img-blog.csdnimg.cn/20200408161258604.jpg)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n- # 总结\n\n​    享元模式的优点：\n\n​    1.减少对象的创建，降低内存中对象的数量，降低系统中的内存，提高效率。\n\n​    2.减少内存之外的其他资源的占用。\n\n​    享元模式的缺点：\n\n​    1.关注内部，外部状态，关注线程安全问题。\n\n​    2.使系统，程序的逻辑复杂化。"},{"title":"【项目总结】p2p项目个人总结","url":"/2020/04/15/hello-world/","content":"## 1.p2p项目分几个部分?3天实现了哪些功能?\n\n### (后台页面的登录与退出:)\n\n#### \ta.后台管理的登录\n\n​\t\t1.创建包结构,导入jar包,导入从c3p0文件,修改c3p0的配置\n\n​\t\t2.将html文件转换成jsp文件,修改jsp页面中的配置路径\n\n​\t\t3.编写创建servlet文件,service文件和dao文件\n\n​\t\t4.创建user类和user表相对应\n\n​\t\t5.在servlet中获取请求方式,创建一个login方法\n\n​\t\t6.在login方法中接受用户名和密码\n\n​\t\t7.进行非空校验,如果为空,页面重定向\n\n​\t\t8.调用service层,编写login方法,传入用户名和密码的参数\n\n​\t\t9.创建jdbcutils工具\n\n​\t\t10.调用dao层,连接数据库根据用户名和密码查询user,将得到user结果返回\n\n​\t\t11.判断user是否为空,将数据存到request,页面跳转或者重定向\n\n​\t\t12.在login.jsp显示存入的错误信息\n\n#### \tb.登录的过滤\n\n​\t\t1.把home.jsp文件放到views路径下\n\n​\t\t2.创建index.jsp文件\n\n​\t\t3.创建一个filter过滤器\n\n​\t\t4.在过滤器中获取session中的user\n\n​\t\t5.判断user是否为空,为空表示未登录,页面重定向\n\n​\t\t6.不为空表示已登录,放行\n\n​\t\t7.在xml中配置filter\n\n#### \tc.用户退出\n\n​\t\t1.在退出按钮前面添加显示user的名称\n\n​\t\t2.在home.jsp中给按钮标签添href属性传入参数method=logout,添加onclick事件\n\n​\t\t3.在userservlet中接受method参数,编写logout方法\n\n​\t\t4.在logout方法中销毁session,然后页面重定向\n\n\n\n### (产品的增加与修改:)\n\n#### \td.产品的查询\n\n​\t\t1.创建product类,与表相对应\n\n​\t\t2.创建home.js,在home.jsp导入js\n\n​\t\t3.在home.js中编写查询所有产品的函数,页面加载完成后执行函数\n\n​\t\t4.在函数中,向服务器发送请求,传入method参数\n\n​\t\t5.编写productservlet页面\n\n​\t\t6.接受method参数,执行查询所有的方法\n\n​\t\t7.在方法中,调用service层,执行查询的方法,返回一个list集合\n\n​\t\t8.在service中调用dao层\n\n​\t\t9.在DAO层中,查询数据库,将结果以list集合形式返回\n\n​\t\t10.在js页面接受返回的list集合！\n\n​\t\t11.编写展示产品信息的js代码\n\n#### \te.产品的添加,之查询产品信息\n\n​\t\t1.给新增产品按钮添加click事件,绑定添加产品的函数\n\n​\t\t2.copy代码,在函数中弹出添加产品的层\n\n​\t\t3.在函数中,给弹出层的表格添加click事件\n\n​\t\t4.在click事件中调用serialize方法封装表格中的数据\n\n​\t\t5.向服务器发送请求\n\n​\t\t6.在servlet中接受请求方式,编写add的方法\n\n​\t\t7.在add方法中,创建product对象\n\n​\t\t8.使用beanutils封装数据到product对象\n\n​\t\t9.调用service层执行添加产品的方法\n\n​\t\t10.调用dao层,连接数据库向product表中插入数据\n\n#### f.产品的修改,先查询产品信息,展示到弹出层\n\n​\t\t1.给编辑的a标签添加click事件,绑定修改产品的函数\n\n​\t\t2.在函数中,先修改弹出的层标题和按钮\n\n​\t\t3.在函数中,根据点击编辑的id,向服务器发送请求,传入id和根据id查产品采的方法参数\n\n​\t\t4.接受method参数,执行根据id查询的方法\n\n​\t\t5.调用service层,调用dao层查询产品信息,将数据返回\n\n​\t\t6.给弹出层的每个input添加id,将返回的数据显示在input中\n\n​\t\t7.在添加产品的函数中将input中的内容清空\n\n​\t\t8.给修改按钮绑定click事件,点击按钮,触发函数\n\n​\t\t9.在函数中将input中的内容封装打包,携带id的参数\n\n​\t\t10.向服务器发送请求,传入参数,method=editproduct\n\n​\t\t11.在servlet中接受参数,创建product对象,使用beautils工具封装数据到product对象中\n\n​\t\t12.调用service和dao层,编写editproduct方法\n\n​\t\t13.在修改按钮绑定的函数中,先将弹出层关闭\n\n​\t\t14.重新执行查询所有产品的函数,产品信息改变说明产品信息修改成功\n\n#### g.一些BUG的修改\n\n​\t\t\t1.在新增产品的按钮绑定点击事件之间先解绑\n\n​\t\t\t2.在编辑按钮绑定点击事件之间先解绑\n\n\n\n### (前台页面的登录:)\n\n#### \ta.验证码的显示与点击切换\n\n​\t\t1.复制文件到utils里面,配置servlet\n\n​\t\t2.在login.html验证码的后面添加img标签和href属性,取一个id\n\n​\t\t3.在img标签里面添加click函数\n\n​\t\t4.在customer.js里面编写函数,导入js\n\n​\t\t5.取到id然后attr设置src属性\n\n#### \tb.点击立即登录按钮,进行登录\n\n​\t\t1.在input框里添加name属性,给按钮注册onclick事件\n\n​\t\t2.在js页面,编写login函数\n\n​\t\t3.把输入框的数据封装在json里面\n\n​\t\t4.向服务器发送请求\n\n#### \tc.servlet里面的登录操作\n\n​\t\t1.接受三个参数\n​\t\t2.判断验证码\n​\t\t2.1从session中取到checkcode\n​\t\t2.2判断两个checkcode\n​\t\t3.调用service层,执行login方法\n​\t\t4.创建customer对象\n​\t\t5.把customer对象存入到session中\n​\t\t6.判读是不是空\n​\t\t7.创建jsonResout对象 \n\n​\t\t8.设置type和error,并写会到浏览器\n\n\n\n#### \td.用户输入邮箱也可以登录\n\n​\t\t1.在掉serivce层之前判断录入的是不是邮箱的正则\n​\t\t2.如果是的,调用findbyemail方法,查到用户对象\n​\t\t3.把c_name设置成c.getc_name;\n​\t\t4.导入StringUtils文件\n​\t\t5.在添加表数据和登录的时候,调用stringUtils的MD5方法加密文件\n​\t\t6.在数据库中也对密码进行加密\n\n​\t\t7.设置password的字段为50\n\n​\t\t"}]